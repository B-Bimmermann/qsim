diff -r -u qemu-0.12.3/cpu-all.h qemu-0.12.3-qsim/cpu-all.h
--- qemu-0.12.3/cpu-all.h	2010-02-23 15:54:38.000000000 -0500
+++ qemu-0.12.3-qsim/cpu-all.h	2012-02-09 03:07:37.000000000 -0500
@@ -16,9 +16,13 @@
  * You should have received a copy of the GNU Lesser General Public
  * License along with this library; if not, see <http://www.gnu.org/licenses/>.
  */
+
 #ifndef CPU_ALL_H
 #define CPU_ALL_H
 
+extern uint64_t qsim_phys_addr;
+extern uint64_t qsim_host_addr;
+
 #include "qemu-common.h"
 #include "cpu-common.h"
 
@@ -651,8 +655,8 @@
 #else /* !CONFIG_USER_ONLY */
 /* NOTE: we use double casts if pointers and target_ulong have
    different sizes */
-#define saddr(x) (uint8_t *)(long)(x)
-#define laddr(x) (uint8_t *)(long)(x)
+#define saddr(x) (uint8_t*)(qsim_host_addr = (long)(x))
+#define laddr(x) (uint8_t*)(qsim_host_addr = (long)(x))
 #endif
 
 #define ldub_raw(p) ldub_p(laddr((p)))
diff -r -u qemu-0.12.3/cpu-common.h qemu-0.12.3-qsim/cpu-common.h
--- qemu-0.12.3/cpu-common.h	2010-02-23 15:54:38.000000000 -0500
+++ qemu-0.12.3-qsim/cpu-common.h	2012-02-09 03:07:37.000000000 -0500
@@ -29,6 +29,7 @@
 }
 
 ram_addr_t cpu_get_physical_page_desc(target_phys_addr_t addr);
+ram_addr_t qemu_ram_share(ram_addr_t, void*);
 ram_addr_t qemu_ram_alloc(ram_addr_t);
 void qemu_ram_free(ram_addr_t addr);
 /* This should only be used for ram local to a device.  */
diff -r -u qemu-0.12.3/cpu-exec.c qemu-0.12.3-qsim/cpu-exec.c
--- qemu-0.12.3/cpu-exec.c	2010-02-23 15:54:38.000000000 -0500
+++ qemu-0.12.3-qsim/cpu-exec.c	2012-02-09 03:07:37.000000000 -0500
@@ -38,6 +38,11 @@
 #endif
 #endif
 
+extern int             qsim_cur_cpu    ;
+extern int             qsim_irq_pending;
+extern uint8_t         qsim_irq_vec    ;
+extern pthread_mutex_t qsim_irq_lock   ;
+
 #if defined(__sparc__) && !defined(CONFIG_SOLARIS)
 // Work around ugly bugs in glibc that mangle global register contents
 #undef env
@@ -83,9 +88,9 @@
     if (puc) {
         /* XXX: use siglongjmp ? */
 #ifdef __linux__
-        sigprocmask(SIG_SETMASK, &uc->uc_sigmask, NULL);
+      //sigprocmask(SIG_SETMASK, &uc->uc_sigmask, NULL);
 #elif defined(__OpenBSD__)
-        sigprocmask(SIG_SETMASK, &uc->sc_mask, NULL);
+      //sigprocmask(SIG_SETMASK, &uc->sc_mask, NULL);
 #endif
     }
 #endif
@@ -390,7 +395,14 @@
                             int intno;
                             svm_check_intercept(SVM_EXIT_INTR);
                             env->interrupt_request &= ~(CPU_INTERRUPT_HARD | CPU_INTERRUPT_VIRQ);
-                            intno = cpu_get_pic_interrupt(env);
+			    pthread_mutex_lock(&qsim_irq_lock);
+                            if (qsim_irq_pending) {
+			      intno = qsim_irq_vec;
+                              qsim_irq_pending = 0;
+			      } else {
+                              intno = cpu_get_pic_interrupt(env);
+			    }
+			    pthread_mutex_unlock(&qsim_irq_lock);
                             qemu_log_mask(CPU_LOG_TB_IN_ASM, "Servicing hardware INT=0x%02x\n", intno);
 #if defined(__sparc__) && !defined(CONFIG_SOLARIS)
 #undef env
@@ -793,7 +805,7 @@
 
     /* we restore the process signal mask as the sigreturn should
        do it (XXX: use sigsetjmp) */
-    sigprocmask(SIG_SETMASK, old_set, NULL);
+    //sigprocmask(SIG_SETMASK, old_set, NULL);
     EXCEPTION_ACTION;
 
     /* never comes here */
diff -r -u qemu-0.12.3/exec.c qemu-0.12.3-qsim/exec.c
--- qemu-0.12.3/exec.c	2010-02-23 15:54:38.000000000 -0500
+++ qemu-0.12.3-qsim/exec.c	2012-02-09 03:07:37.000000000 -0500
@@ -438,7 +438,7 @@
 
         flags = MAP_PRIVATE | MAP_ANONYMOUS;
 #if defined(__x86_64__)
-        flags |= MAP_32BIT;
+        // flags |= MAP_32BIT; //QSIM: We shouldn't need this.
         /* Cannot map more than that */
         if (code_gen_buffer_size > (800 * 1024 * 1024))
             code_gen_buffer_size = (800 * 1024 * 1024);
@@ -2404,6 +2404,34 @@
         kvm_uncoalesce_mmio_region(addr, size);
 }
 
+ram_addr_t qemu_ram_share(ram_addr_t size, void* ptr)
+{
+  RAMBlock *new_block;
+
+  size = TARGET_PAGE_ALIGN(size);
+  new_block = qemu_malloc(sizeof(*new_block));
+
+  new_block->host = ptr;
+
+  new_block->offset = last_ram_offset;
+  new_block->length = size;
+
+  new_block->next = ram_blocks;
+  ram_blocks = new_block;
+
+  phys_ram_dirty = qemu_realloc(phys_ram_dirty,
+                                (last_ram_offset + size) >> TARGET_PAGE_BITS);
+  memset(phys_ram_dirty + (last_ram_offset >> TARGET_PAGE_BITS),
+         0xff, size >> TARGET_PAGE_BITS);
+
+  last_ram_offset += size;
+
+  if (kvm_enabled())
+    kvm_setup_guest_memory(new_block->host, size);
+
+  return new_block->offset;
+}
+
 ram_addr_t qemu_ram_alloc(ram_addr_t size)
 {
     RAMBlock *new_block;
diff -r -u qemu-0.12.3/hw/apic.c qemu-0.12.3-qsim/hw/apic.c
--- qemu-0.12.3/hw/apic.c	2010-02-23 15:54:38.000000000 -0500
+++ qemu-0.12.3-qsim/hw/apic.c	2012-02-09 03:07:37.000000000 -0500
@@ -185,7 +185,7 @@
 void apic_deliver_pic_intr(CPUState *env, int level)
 {
     if (level)
-        apic_local_deliver(env, APIC_LVT_LINT0);
+      ;//apic_local_deliver(env, APIC_LVT_LINT0);
     else {
         APICState *s = env->apic_state;
         uint32_t lvt = s->lvt[APIC_LVT_LINT0];
@@ -287,8 +287,8 @@
     uint32_t deliver_bitmask[MAX_APIC_WORDS];
 
     apic_get_delivery_bitmask(deliver_bitmask, dest, dest_mode);
-    apic_bus_deliver(deliver_bitmask, delivery_mode, vector_num, polarity,
-                     trigger_mode);
+    //apic_bus_deliver(deliver_bitmask, delivery_mode, vector_num, polarity,
+    //                 trigger_mode);
 }
 
 void cpu_set_apic_base(CPUState *env, uint64_t val)
@@ -343,7 +343,7 @@
             return i * 32 + fls_bit(tab[i]);
         }
     }
-    return -1;
+    return -11;
 }
 
 static int apic_get_ppr(APICState *s)
@@ -565,8 +565,8 @@
             return;
     }
 
-    apic_bus_deliver(deliver_bitmask, delivery_mode, vector_num, polarity,
-                     trigger_mode);
+    //apic_bus_deliver(deliver_bitmask, delivery_mode, vector_num, polarity,
+    //                 trigger_mode);
 }
 
 int apic_get_interrupt(CPUState *env)
@@ -645,11 +645,11 @@
             d = (uint64_t)s->initial_count + 1;
         }
         next_time = s->initial_count_load_time + (d << s->count_shift);
-        qemu_mod_timer(s->timer, next_time);
+        //qemu_mod_timer(s->timer, next_time);
         s->next_time = next_time;
     } else {
-    no_timer:
-        qemu_del_timer(s->timer);
+    no_timer:;
+      //qemu_del_timer(s->timer);
     }
 }
 
@@ -657,7 +657,7 @@
 {
     APICState *s = opaque;
 
-    apic_local_deliver(s->cpu_env, APIC_LVT_TIMER);
+    //apic_local_deliver(s->cpu_env, APIC_LVT_TIMER);
     apic_timer_update(s, s->next_time);
 }
 
@@ -757,7 +757,7 @@
 #ifdef DEBUG_APIC
     printf("APIC read: %08x = %08x\n", (uint32_t)addr, val);
 #endif
-    return val;
+    return /*val*/0;
 }
 
 static void apic_send_msi(target_phys_addr_t addr, uint32 data)
@@ -775,6 +775,7 @@
 {
     CPUState *env;
     APICState *s;
+
     int index = (addr >> 4) & 0xff;
     if (addr > 0xfff || !index) {
         /* MSI and MMIO APIC are at the same memory location,
@@ -899,7 +900,7 @@
     s->next_time=qemu_get_be64(f);
 
     if (version_id >= 2)
-        qemu_get_timer(f, s->timer);
+      ;//qemu_get_timer(f, s->timer);
     return 0;
 }
 
@@ -993,7 +994,7 @@
         cpu_register_physical_memory(MSI_ADDR_BASE, MSI_ADDR_SIZE,
                                      apic_io_memory);
     }
-    s->timer = qemu_new_timer(vm_clock, apic_timer, s);
+    //s->timer = qemu_new_timer(vm_clock, apic_timer, s);
 
     vmstate_register(s->idx, &vmstate_apic, s);
     qemu_register_reset(apic_reset, s);
diff -r -u qemu-0.12.3/hw/pc.c qemu-0.12.3-qsim/hw/pc.c
--- qemu-0.12.3/hw/pc.c	2010-02-23 15:54:38.000000000 -0500
+++ qemu-0.12.3-qsim/hw/pc.c	2012-02-09 03:07:37.000000000 -0500
@@ -45,6 +45,10 @@
 #include "loader.h"
 #include "elf.h"
 
+#include "qsim-vm.h"
+extern int               qsim_qemu_is_slave;
+extern pthread_rwlock_t *qsim_atomic_lock;
+
 /* output Bochs bios info messages */
 //#define DEBUG_BIOS
 
@@ -65,8 +69,8 @@
 #define MAX_IDE_BUS 2
 
 static fdctrl_t *floppy_controller;
-static RTCState *rtc_state;
-static PITState *pit;
+//static RTCState *rtc_state;
+//static PITState *pit;
 static PCII440FXState *i440fx_state;
 
 typedef struct isa_irq_state {
@@ -158,216 +162,6 @@
 
 #define REG_EQUIPMENT_BYTE          0x14
 
-static int cmos_get_fd_drive_type(int fd0)
-{
-    int val;
-
-    switch (fd0) {
-    case 0:
-        /* 1.44 Mb 3"5 drive */
-        val = 4;
-        break;
-    case 1:
-        /* 2.88 Mb 3"5 drive */
-        val = 5;
-        break;
-    case 2:
-        /* 1.2 Mb 5"5 drive */
-        val = 2;
-        break;
-    default:
-        val = 0;
-        break;
-    }
-    return val;
-}
-
-static void cmos_init_hd(int type_ofs, int info_ofs, BlockDriverState *hd)
-{
-    RTCState *s = rtc_state;
-    int cylinders, heads, sectors;
-    bdrv_get_geometry_hint(hd, &cylinders, &heads, &sectors);
-    rtc_set_memory(s, type_ofs, 47);
-    rtc_set_memory(s, info_ofs, cylinders);
-    rtc_set_memory(s, info_ofs + 1, cylinders >> 8);
-    rtc_set_memory(s, info_ofs + 2, heads);
-    rtc_set_memory(s, info_ofs + 3, 0xff);
-    rtc_set_memory(s, info_ofs + 4, 0xff);
-    rtc_set_memory(s, info_ofs + 5, 0xc0 | ((heads > 8) << 3));
-    rtc_set_memory(s, info_ofs + 6, cylinders);
-    rtc_set_memory(s, info_ofs + 7, cylinders >> 8);
-    rtc_set_memory(s, info_ofs + 8, sectors);
-}
-
-/* convert boot_device letter to something recognizable by the bios */
-static int boot_device2nibble(char boot_device)
-{
-    switch(boot_device) {
-    case 'a':
-    case 'b':
-        return 0x01; /* floppy boot */
-    case 'c':
-        return 0x02; /* hard drive boot */
-    case 'd':
-        return 0x03; /* CD-ROM boot */
-    case 'n':
-        return 0x04; /* Network boot */
-    }
-    return 0;
-}
-
-/* copy/pasted from cmos_init, should be made a general function
- and used there as well */
-static int pc_boot_set(void *opaque, const char *boot_device)
-{
-    Monitor *mon = cur_mon;
-#define PC_MAX_BOOT_DEVICES 3
-    RTCState *s = (RTCState *)opaque;
-    int nbds, bds[3] = { 0, };
-    int i;
-
-    nbds = strlen(boot_device);
-    if (nbds > PC_MAX_BOOT_DEVICES) {
-        monitor_printf(mon, "Too many boot devices for PC\n");
-        return(1);
-    }
-    for (i = 0; i < nbds; i++) {
-        bds[i] = boot_device2nibble(boot_device[i]);
-        if (bds[i] == 0) {
-            monitor_printf(mon, "Invalid boot device for PC: '%c'\n",
-                           boot_device[i]);
-            return(1);
-        }
-    }
-    rtc_set_memory(s, 0x3d, (bds[1] << 4) | bds[0]);
-    rtc_set_memory(s, 0x38, (bds[2] << 4));
-    return(0);
-}
-
-/* hd_table must contain 4 block drivers */
-static void cmos_init(ram_addr_t ram_size, ram_addr_t above_4g_mem_size,
-                      const char *boot_device, DriveInfo **hd_table)
-{
-    RTCState *s = rtc_state;
-    int nbds, bds[3] = { 0, };
-    int val;
-    int fd0, fd1, nb;
-    int i;
-
-    /* various important CMOS locations needed by PC/Bochs bios */
-
-    /* memory size */
-    val = 640; /* base memory in K */
-    rtc_set_memory(s, 0x15, val);
-    rtc_set_memory(s, 0x16, val >> 8);
-
-    val = (ram_size / 1024) - 1024;
-    if (val > 65535)
-        val = 65535;
-    rtc_set_memory(s, 0x17, val);
-    rtc_set_memory(s, 0x18, val >> 8);
-    rtc_set_memory(s, 0x30, val);
-    rtc_set_memory(s, 0x31, val >> 8);
-
-    if (above_4g_mem_size) {
-        rtc_set_memory(s, 0x5b, (unsigned int)above_4g_mem_size >> 16);
-        rtc_set_memory(s, 0x5c, (unsigned int)above_4g_mem_size >> 24);
-        rtc_set_memory(s, 0x5d, (uint64_t)above_4g_mem_size >> 32);
-    }
-
-    if (ram_size > (16 * 1024 * 1024))
-        val = (ram_size / 65536) - ((16 * 1024 * 1024) / 65536);
-    else
-        val = 0;
-    if (val > 65535)
-        val = 65535;
-    rtc_set_memory(s, 0x34, val);
-    rtc_set_memory(s, 0x35, val >> 8);
-
-    /* set the number of CPU */
-    rtc_set_memory(s, 0x5f, smp_cpus - 1);
-
-    /* set boot devices, and disable floppy signature check if requested */
-#define PC_MAX_BOOT_DEVICES 3
-    nbds = strlen(boot_device);
-    if (nbds > PC_MAX_BOOT_DEVICES) {
-        fprintf(stderr, "Too many boot devices for PC\n");
-        exit(1);
-    }
-    for (i = 0; i < nbds; i++) {
-        bds[i] = boot_device2nibble(boot_device[i]);
-        if (bds[i] == 0) {
-            fprintf(stderr, "Invalid boot device for PC: '%c'\n",
-                    boot_device[i]);
-            exit(1);
-        }
-    }
-    rtc_set_memory(s, 0x3d, (bds[1] << 4) | bds[0]);
-    rtc_set_memory(s, 0x38, (bds[2] << 4) | (fd_bootchk ?  0x0 : 0x1));
-
-    /* floppy type */
-
-    fd0 = fdctrl_get_drive_type(floppy_controller, 0);
-    fd1 = fdctrl_get_drive_type(floppy_controller, 1);
-
-    val = (cmos_get_fd_drive_type(fd0) << 4) | cmos_get_fd_drive_type(fd1);
-    rtc_set_memory(s, 0x10, val);
-
-    val = 0;
-    nb = 0;
-    if (fd0 < 3)
-        nb++;
-    if (fd1 < 3)
-        nb++;
-    switch (nb) {
-    case 0:
-        break;
-    case 1:
-        val |= 0x01; /* 1 drive, ready for boot */
-        break;
-    case 2:
-        val |= 0x41; /* 2 drives, ready for boot */
-        break;
-    }
-    val |= 0x02; /* FPU is there */
-    val |= 0x04; /* PS/2 mouse installed */
-    rtc_set_memory(s, REG_EQUIPMENT_BYTE, val);
-
-    /* hard drives */
-
-    rtc_set_memory(s, 0x12, (hd_table[0] ? 0xf0 : 0) | (hd_table[1] ? 0x0f : 0));
-    if (hd_table[0])
-        cmos_init_hd(0x19, 0x1b, hd_table[0]->bdrv);
-    if (hd_table[1])
-        cmos_init_hd(0x1a, 0x24, hd_table[1]->bdrv);
-
-    val = 0;
-    for (i = 0; i < 4; i++) {
-        if (hd_table[i]) {
-            int cylinders, heads, sectors, translation;
-            /* NOTE: bdrv_get_geometry_hint() returns the physical
-                geometry.  It is always such that: 1 <= sects <= 63, 1
-                <= heads <= 16, 1 <= cylinders <= 16383. The BIOS
-                geometry can be different if a translation is done. */
-            translation = bdrv_get_translation_hint(hd_table[i]->bdrv);
-            if (translation == BIOS_ATA_TRANSLATION_AUTO) {
-                bdrv_get_geometry_hint(hd_table[i]->bdrv, &cylinders, &heads, &sectors);
-                if (cylinders <= 1024 && heads <= 16 && sectors <= 63) {
-                    /* No translation. */
-                    translation = 0;
-                } else {
-                    /* LBA translation. */
-                    translation = 1;
-                }
-            } else {
-                translation--;
-            }
-            val |= translation << (i * 2);
-        }
-    }
-    rtc_set_memory(s, 0x39, val);
-}
-
 void ioport_set_a20(int enable)
 {
     /* XXX: send to all CPUs ? */
@@ -986,7 +780,7 @@
     ram_addr_t below_4g_mem_size, above_4g_mem_size = 0;
     int bios_size, isa_bios_size;
     PCIBus *pci_bus;
-    ISADevice *isa_dev;
+  //ISADevice *isa_dev;
     int piix3_devfn = -1;
     CPUState *env;
     qemu_irq *cpu_irq;
@@ -997,6 +791,8 @@
     DriveInfo *fd[MAX_FD];
     void *fw_cfg;
 
+    pci_enabled = 0;
+
     if (ram_size >= 0xe0000000 ) {
         above_4g_mem_size = ram_size - 0xe0000000;
         below_4g_mem_size = 0xe0000000;
@@ -1021,60 +817,74 @@
 
     vmport_init();
 
-    /* allocate RAM */
-    ram_addr = qemu_ram_alloc(0xa0000);
-    cpu_register_physical_memory(0, 0xa0000, ram_addr);
-
-    /* Allocate, even though we won't register, so we don't break the
-     * phys_ram_base + PA assumption. This range includes vga (0xa0000 - 0xc0000),
-     * and some bios areas, which will be registered later
+    /* If there is no external QSIM RAM, allocate RAM and the 
+     * qemu_ramdesc_t struct. 
      */
-    ram_addr = qemu_ram_alloc(0x100000 - 0xa0000);
-    ram_addr = qemu_ram_alloc(below_4g_mem_size - 0x100000);
-    cpu_register_physical_memory(0x100000,
-                 below_4g_mem_size - 0x100000,
-                 ram_addr);
+    if (qsim_ram == NULL) {
+      /* allocate the qsim_ram structure */
+      qsim_ram = qemu_mallocz(sizeof(qemu_ramdesc_t));
+
+      /* initialize the sync bit. */
+      pthread_rwlock_init(&qsim_ram->atomic_lock, NULL);
+      qsim_atomic_lock = &qsim_ram->atomic_lock;
+
+      /* allocate RAM */
+      ram_addr = qemu_ram_alloc(0xa0000);
+      cpu_register_physical_memory(0, 0xa0000, ram_addr);
+      qsim_ram->low_mem_sz  = 0xa0000;
+      qsim_ram->low_mem_ptr = qemu_get_ram_ptr(ram_addr);
+
+      /* Allocate, even though we won't register, so we don't break the
+       * phys_ram_base + PA assumption. This range includes vga,
+       * and some bios areas, which will be registered later
+       */
+      ram_addr = qemu_ram_alloc(0x100000 - 0xa0000);
+      ram_addr = qemu_ram_alloc(below_4g_mem_size - 0x100000);
+      cpu_register_physical_memory(0x100000,
+                   below_4g_mem_size - 0x100000,
+                   ram_addr);
+      qsim_ram->below_4g_sz  = below_4g_mem_size - 0x100000;
+      qsim_ram->below_4g_ptr = qemu_get_ram_ptr(ram_addr);
 
-    /* above 4giga memory allocation */
-    if (above_4g_mem_size > 0) {
+      /* above 4giga memory allocation */
+      if (above_4g_mem_size > 0) {
 #if TARGET_PHYS_ADDR_BITS == 32
-        hw_error("To much RAM for 32-bit physical address");
+          hw_error("To much RAM for 32-bit physical address");
 #else
-        ram_addr = qemu_ram_alloc(above_4g_mem_size);
+          ram_addr = qemu_ram_alloc(above_4g_mem_size);
+          cpu_register_physical_memory(0x100000000ULL,
+                                       above_4g_mem_size,
+                                       ram_addr);
+          qsim_ram->above_4g_sz  = above_4g_mem_size;
+          qsim_ram->above_4g_ptr = qemu_get_ram_ptr(ram_addr);
+#endif
+      }
+    } else {
+      if (qsim_ram->low_mem_sz != 0) {
+        ram_addr = qemu_ram_share(qsim_ram->low_mem_sz, qsim_ram->low_mem_ptr);
+        cpu_register_physical_memory(0, 
+                                     qsim_ram->low_mem_sz, 
+                                     ram_addr);
+      }
+
+      if (qsim_ram->below_4g_sz != 0) {
+        ram_addr = qemu_ram_share(qsim_ram->below_4g_sz, 
+                                  qsim_ram->below_4g_ptr);
+        cpu_register_physical_memory(0x100000, 
+                                     qsim_ram->below_4g_sz,
+                                     ram_addr);
+      }
+
+      if (qsim_ram->above_4g_sz != 0) {
+        ram_addr = qemu_ram_share(qsim_ram->above_4g_sz, 
+                                  qsim_ram->above_4g_ptr);
         cpu_register_physical_memory(0x100000000ULL,
-                                     above_4g_mem_size,
+                                     qsim_ram->above_4g_sz,
                                      ram_addr);
-#endif
+      }
     }
 
 
-    /* BIOS load */
-    if (bios_name == NULL)
-        bios_name = BIOS_FILENAME;
-    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
-    if (filename) {
-        bios_size = get_image_size(filename);
-    } else {
-        bios_size = -1;
-    }
-    if (bios_size <= 0 ||
-        (bios_size % 65536) != 0) {
-        goto bios_error;
-    }
-    bios_offset = qemu_ram_alloc(bios_size);
-    ret = rom_add_file_fixed(bios_name, (uint32_t)(-bios_size));
-    if (ret != 0) {
-    bios_error:
-        fprintf(stderr, "qemu: could not load PC BIOS '%s'\n", bios_name);
-        exit(1);
-    }
-    if (filename) {
-        qemu_free(filename);
-    }
-    /* map the last 128KB of the BIOS in ISA space */
-    isa_bios_size = bios_size;
-    if (isa_bios_size > (128 * 1024))
-        isa_bios_size = 128 * 1024;
     cpu_register_physical_memory(0x100000 - isa_bios_size,
                                  isa_bios_size,
                                  (bios_offset + bios_size - isa_bios_size) | IO_MEM_ROM);
@@ -1092,7 +902,7 @@
     fw_cfg = bochs_bios_init();
     rom_set_fw(fw_cfg);
 
-    if (linux_boot) {
+    if (linux_boot && !qsim_qemu_is_slave) {
         load_linux(fw_cfg, kernel_filename, initrd_filename, kernel_cmdline, below_4g_mem_size);
     }
 
@@ -1121,6 +931,7 @@
 
     register_ioport_write(0xf0, 1, 1, ioportF0_write, NULL);
 
+#if 0
     if (cirrus_vga_enabled) {
         if (pci_enabled) {
             pci_cirrus_vga_init(pci_bus);
@@ -1139,10 +950,11 @@
             isa_vga_init();
         }
     }
+#endif
 
-    rtc_state = rtc_init(2000);
+    //rtc_state = rtc_init(2000);
 
-    qemu_register_boot_set(pc_boot_set, rtc_state);
+    //qemu_register_boot_set(pc_boot_set, rtc_state);
 
     register_ioport_read(0x92, 1, 1, ioport92_read, NULL);
     register_ioport_write(0x92, 1, 1, ioport92_write, NULL);
@@ -1150,12 +962,13 @@
     if (pci_enabled) {
         isa_irq_state->ioapic = ioapic_init();
     }
-    pit = pit_init(0x40, isa_reserve_irq(0));
-    pcspk_init(pit);
+    //pit = pit_init(0x40, isa_reserve_irq(0));
+    //pcspk_init(pit);
     if (!no_hpet) {
         hpet_init(isa_irq);
     }
 
+#if 0
     for(i = 0; i < MAX_SERIAL_PORTS; i++) {
         if (serial_hds[i]) {
             serial_isa_init(i, serial_hds[i]);
@@ -1167,6 +980,7 @@
             parallel_init(i, parallel_hds[i]);
         }
     }
+#endif
 
     for(i = 0; i < nb_nics; i++) {
         NICInfo *nd = &nd_table[i];
@@ -1186,6 +1000,7 @@
         hd[i] = drive_get(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);
     }
 
+#if 0
     if (pci_enabled) {
         pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1);
     } else {
@@ -1194,9 +1009,10 @@
 	                 hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);
         }
     }
+#endif
 
-    isa_dev = isa_create_simple("i8042");
-    DMA_init(0);
+  //isa_dev = isa_create_simple("i8042");
+  //DMA_init(0);
 #ifdef HAS_AUDIO
     audio_init(pci_enabled ? pci_bus : NULL, isa_irq);
 #endif
@@ -1206,11 +1022,13 @@
     }
     floppy_controller = fdctrl_init_isa(fd);
 
-    cmos_init(below_4g_mem_size, above_4g_mem_size, boot_device, hd);
+    //cmos_init(below_4g_mem_size, above_4g_mem_size, boot_device, hd);
 
+#if 0
     if (pci_enabled && usb_enabled) {
         usb_uhci_piix3_init(pci_bus, piix3_devfn + 2);
     }
+#endif
 
     if (pci_enabled && acpi_enabled) {
         uint8_t *eeprom_buf = qemu_mallocz(8 * 256); /* XXX: make this persistent */
@@ -1283,8 +1101,8 @@
    BIOS will read it and start S3 resume at POST Entry */
 void cmos_set_s3_resume(void)
 {
-    if (rtc_state)
-        rtc_set_memory(rtc_state, 0xF, 0xFE);
+  //if (rtc_state)
+  //      rtc_set_memory(rtc_state, 0xF, 0xFE);
 }
 
 static QEMUMachine pc_machine = {
diff -r -u qemu-0.12.3/posix-aio-compat.c qemu-0.12.3-qsim/posix-aio-compat.c
--- qemu-0.12.3/posix-aio-compat.c	2010-02-23 15:54:38.000000000 -0500
+++ qemu-0.12.3-qsim/posix-aio-compat.c	2012-02-09 03:07:37.000000000 -0500
@@ -368,6 +368,9 @@
 {
     sigset_t set, oldset;
 
+    fprintf(stderr, "Invalid call.");
+    exit(1);
+
     cur_threads++;
     idle_threads++;
 
diff -r -u qemu-0.12.3/softmmu_header.h qemu-0.12.3-qsim/softmmu_header.h
--- qemu-0.12.3/softmmu_header.h	2010-02-23 15:54:38.000000000 -0500
+++ qemu-0.12.3-qsim/softmmu_header.h	2012-02-09 03:07:37.000000000 -0500
@@ -16,6 +16,48 @@
  * You should have received a copy of the GNU Lesser General Public
  * License along with this library; if not, see <http://www.gnu.org/licenses/>.
  */
+#ifndef QSIM_DEFS
+#define QSIM_DEFS
+#include "qsim-vm.h"
+
+#define QSIM_XSTRING(x) #x
+#define QSIM_STRING(x) QSIM_XSTRING(x)
+
+extern qemu_ramdesc_t *qsim_ram      ;
+extern mem_cb_t        qsim_mem_cb   ;
+extern int             qsim_cur_cpu  ;
+
+static inline uint64_t qsim_ram_addr_from_host(void* qsim_host_addr) {
+  uint64_t paddr;
+
+  if (qsim_host_addr >= (void*)qsim_ram->low_mem_ptr && 
+   qsim_host_addr < (void*)(qsim_ram->low_mem_ptr + qsim_ram->low_mem_sz))
+    paddr = (uint64_t)qsim_host_addr - (uint64_t)qsim_ram->low_mem_ptr;
+  else if (qsim_host_addr >= (void*)qsim_ram->below_4g_ptr &&
+	qsim_host_addr < (void*)(qsim_ram->below_4g_ptr+qsim_ram->below_4g_sz))
+    paddr = (uint64_t)qsim_host_addr - (uint64_t)qsim_ram->below_4g_ptr 
+            + (1<<20);
+  else if (qsim_host_addr >= (void*)qsim_ram->above_4g_ptr &&
+	qsim_host_addr < (void*)(qsim_ram->above_4g_ptr+qsim_ram->above_4g_sz))
+    paddr = (uint64_t)qsim_host_addr - (uint64_t)qsim_ram->above_4g_ptr
+            + (4l<<30);
+  else
+    paddr = 0;
+  // Return null if this pointer is not in our RAM table.
+
+  return paddr;
+}
+
+
+static inline void qsim_memop(uint64_t adr, uint64_t size, int type) {
+  if (qsim_mem_cb) {
+    qsim_phys_addr = qsim_ram_addr_from_host((void *)qsim_host_addr);
+    qsim_mem_cb(qsim_cur_cpu, adr, qsim_phys_addr, size, type);
+  }
+}
+
+#endif
+
 #if DATA_SIZE == 8
 #define SUFFIX q
 #define USUFFIX q
@@ -89,6 +131,10 @@
         physaddr = addr + env->tlb_table[mmu_idx][page_index].addend;
         res = glue(glue(ld, USUFFIX), _raw)((uint8_t *)physaddr);
     }
+
+    if (strcmp(QSIM_STRING(MEMSUFFIX), "_code"))
+      qsim_memop(ptr, DATA_SIZE, 0);
+ 
     return res;
 }
 
@@ -110,6 +156,10 @@
         physaddr = addr + env->tlb_table[mmu_idx][page_index].addend;
         res = glue(glue(lds, SUFFIX), _raw)((uint8_t *)physaddr);
     }
+
+    if (strcmp(QSIM_STRING(MEMSUFFIX), "_code"))
+      qsim_memop(ptr, DATA_SIZE, 0);
+
     return res;
 }
 #endif
@@ -135,6 +185,9 @@
         physaddr = addr + env->tlb_table[mmu_idx][page_index].addend;
         glue(glue(st, SUFFIX), _raw)((uint8_t *)physaddr, v);
     }
+
+    if (strcmp(QSIM_STRING(MEMSUFFIX), "_code"))
+      qsim_memop(ptr, DATA_SIZE, 1);
 }
 
 #endif /* ACCESS_TYPE != (NB_MMU_MODES + 1) */
diff -r -u qemu-0.12.3/target-i386/helper.h qemu-0.12.3-qsim/target-i386/helper.h
--- qemu-0.12.3/target-i386/helper.h	2010-02-23 15:54:38.000000000 -0500
+++ qemu-0.12.3-qsim/target-i386/helper.h	2012-02-09 03:07:37.000000000 -0500
@@ -1,4 +1,5 @@
 #include "def-helper.h"
+#include <stdint.h>
 
 DEF_HELPER_FLAGS_1(cc_compute_all, TCG_CALL_PURE, i32, int)
 DEF_HELPER_FLAGS_1(cc_compute_c, TCG_CALL_PURE, i32, int)
@@ -217,4 +218,11 @@
 DEF_HELPER_2(rcrq, tl, tl, tl)
 #endif
 
+/* QSim */
+DEF_HELPER_3(inst_callback, tl, tl, tl, tl)
+DEF_HELPER_2(reg_read_callback, tl, tl, tl)
+DEF_HELPER_2(reg_write_callback, tl, tl, tl)
+DEF_HELPER_2(load_callback, tl, tl, tl)
+DEF_HELPER_3(store_callback, tl, tl, tl, tl)
+
 #include "def-helper.h"
diff -r -u qemu-0.12.3/target-i386/op_helper.c qemu-0.12.3-qsim/target-i386/op_helper.c
--- qemu-0.12.3/target-i386/op_helper.c	2010-02-23 15:54:38.000000000 -0500
+++ qemu-0.12.3-qsim/target-i386/op_helper.c	2012-02-09 06:54:00.000000000 -0500
@@ -20,9 +20,35 @@
 #include "exec.h"
 #include "exec-all.h"
 #include "host-utils.h"
+#include "qsim-vm.h"
+#include "vm-func.h"
 
-//#define DEBUG_PCALL
+#include <pthread.h>
+#include "qsim-context.h"
+
+extern pthread_rwlock_t *qsim_atomic_lock;
+extern atomic_cb_t qsim_atomic_cb;
+extern magic_cb_t  qsim_magic_cb;
+extern int_cb_t    qsim_int_cb;
+extern inst_cb_t   qsim_inst_cb;
+//extern mem_cb_t    qsim_mem_cb;
+extern io_cb_t     qsim_io_cb;
+extern reg_cb_t qsim_reg_cb;
+
+extern uint8_t  qsim_irq_vec;
+extern int      qsim_irq_pending;
+
+extern int qsim_vm_id;
+//extern int qsim_cur_cpu;
 
+extern uint64_t qsim_icount;
+
+extern qsim_ucontext_t qemu_context;
+extern qsim_ucontext_t main_context;
+
+uint64_t qsim_eip;
+
+//#define DEBUG_PCALL
 
 #ifdef DEBUG_PCALL
 #  define LOG_PCALL(...) qemu_log_mask(CPU_LOG_PCALL, ## __VA_ARGS__)
@@ -110,11 +136,21 @@
 
 void helper_lock(void)
 {
+    pthread_rwlock_unlock(qsim_atomic_lock);
+    pthread_rwlock_wrlock(qsim_atomic_lock);
+
+    // Suspend execution immediately if the atomic callback returns nonzero
+    if (qsim_atomic_cb && qsim_atomic_cb(qsim_cur_cpu))
+      swapcontext(&qemu_context, &main_context);
+
     spin_lock(&global_cpu_lock);
 }
 
 void helper_unlock(void)
 {
+    pthread_rwlock_unlock(qsim_atomic_lock);
+    pthread_rwlock_rdlock(qsim_atomic_lock);
+
     spin_unlock(&global_cpu_lock);
 }
 
@@ -140,10 +176,12 @@
     int index;
     target_ulong ptr;
 
+
     if (selector & 0x4)
         dt = &env->ldt;
     else
         dt = &env->gdt;
+
     index = selector & ~7;
     if ((index + 7) > dt->limit)
         return -1;
@@ -558,31 +596,37 @@
 
 void helper_outb(uint32_t port, uint32_t data)
 {
+    if (qsim_io_cb) qsim_io_cb(qsim_cur_cpu, port, 1, 1, data);
     cpu_outb(port, data & 0xff);
 }
 
 target_ulong helper_inb(uint32_t port)
 {
+    if (qsim_io_cb) qsim_io_cb(qsim_cur_cpu, port, 1, 0, 0);
     return cpu_inb(port);
 }
 
 void helper_outw(uint32_t port, uint32_t data)
 {
+    if (qsim_io_cb) qsim_io_cb(qsim_cur_cpu, port, 2, 1, data);
     cpu_outw(port, data & 0xffff);
 }
 
 target_ulong helper_inw(uint32_t port)
 {
+    if (qsim_io_cb) qsim_io_cb(qsim_cur_cpu, port, 2, 0, 0);
     return cpu_inw(port);
 }
 
 void helper_outl(uint32_t port, uint32_t data)
 {
+    if (qsim_io_cb) qsim_io_cb(qsim_cur_cpu, port, 4, 1, data);
     cpu_outl(port, data);
 }
 
 target_ulong helper_inl(uint32_t port)
 {
+    if (qsim_io_cb) qsim_io_cb(qsim_cur_cpu, port, 4, 0, 0);
     return cpu_inl(port);
 }
 
@@ -1211,6 +1255,11 @@
 void do_interrupt(int intno, int is_int, int error_code,
                   target_ulong next_eip, int is_hw)
 {
+  if (qsim_int_cb != NULL && qsim_int_cb(qsim_cur_cpu, intno) && is_int) {
+    env->eip = next_eip;
+    return;
+  }
+
     if (qemu_loglevel_mask(CPU_LOG_INT)) {
         if ((env->cr[0] & CR0_PE_MASK)) {
             static int count;
@@ -1930,13 +1979,23 @@
 {
     uint32_t eax, ebx, ecx, edx;
 
+    eax = (uint32_t)EAX;
+    eax &= 0xfffffff0;
+
+    if (qsim_magic_cb && qsim_magic_cb(qsim_cur_cpu, EAX))
+      swapcontext(&qemu_context, &main_context);
+
     helper_svm_check_intercept_param(SVM_EXIT_CPUID, 0);
 
-    cpu_x86_cpuid(env, (uint32_t)EAX, (uint32_t)ECX, &eax, &ebx, &ecx, &edx);
-    EAX = eax;
-    EBX = ebx;
-    ECX = ecx;
-    EDX = edx;
+    /* Don't perform cpu_x86_cpuid if this is not a valid CPUID 
+      (it is a magic instruction; the magic callback might respond!) */
+    if ( eax == 0x40000000 || eax == 0x80000000 || eax == 0) {
+      cpu_x86_cpuid(env, (uint32_t)EAX, (uint32_t)ECX, &eax, &ebx, &ecx, &edx);
+      EAX = eax;
+      EBX = ebx;
+      ECX = ecx;
+      EDX = edx;
+    }
 }
 
 void helper_enter_level(int level, int data32, target_ulong t1)
@@ -2193,31 +2252,38 @@
 
     if ((new_cs & 0xfffc) == 0)
         raise_exception_err(EXCP0D_GPF, 0);
-    if (load_segment(&e1, &e2, new_cs) != 0)
+    if (load_segment(&e1, &e2, new_cs) != 0) {
         raise_exception_err(EXCP0D_GPF, new_cs & 0xfffc);
+    }
     cpl = env->hflags & HF_CPL_MASK;
     if (e2 & DESC_S_MASK) {
-        if (!(e2 & DESC_CS_MASK))
+      if (!(e2 & DESC_CS_MASK)) {
             raise_exception_err(EXCP0D_GPF, new_cs & 0xfffc);
+      }
         dpl = (e2 >> DESC_DPL_SHIFT) & 3;
         if (e2 & DESC_C_MASK) {
             /* conforming code segment */
-            if (dpl > cpl)
+	  if (dpl > cpl) {
                 raise_exception_err(EXCP0D_GPF, new_cs & 0xfffc);
+	  }
         } else {
             /* non conforming code segment */
             rpl = new_cs & 3;
-            if (rpl > cpl)
+            if (rpl > cpl) {
                 raise_exception_err(EXCP0D_GPF, new_cs & 0xfffc);
-            if (dpl != cpl)
+	    }
+            if (dpl != cpl) {
                 raise_exception_err(EXCP0D_GPF, new_cs & 0xfffc);
+	    }
         }
-        if (!(e2 & DESC_P_MASK))
+        if (!(e2 & DESC_P_MASK)) {
             raise_exception_err(EXCP0B_NOSEG, new_cs & 0xfffc);
+	}
         limit = get_seg_limit(e1, e2);
         if (new_eip > limit &&
-            !(env->hflags & HF_LMA_MASK) && !(e2 & DESC_L_MASK))
+            !(env->hflags & HF_LMA_MASK) && !(e2 & DESC_L_MASK)) {
             raise_exception_err(EXCP0D_GPF, new_cs & 0xfffc);
+	}
         cpu_x86_load_seg_cache(env, R_CS, (new_cs & 0xfffc) | cpl,
                        get_seg_base(e1, e2), limit, e2);
         EIP = new_eip;
@@ -2943,6 +3009,7 @@
     helper_write_crN(0, t0);
 }
 
+// TSC disabled for QSIM; returns zero.
 void helper_clts(void)
 {
     env->cr[0] &= ~CR0_TS_MASK;
@@ -2964,7 +3031,7 @@
     }
     helper_svm_check_intercept_param(SVM_EXIT_RDTSC, 0);
 
-    val = cpu_get_tsc(env) + env->tsc_offset;
+    val = /*cpu_get_tsc(env) + env->tsc_offset*/0;
     EAX = (uint32_t)(val);
     EDX = (uint32_t)(val >> 32);
 }
@@ -5656,3 +5723,242 @@
 #endif
     }
 }
+
+target_ulong helper_inst_callback(target_ulong vaddr, target_ulong 
+                                  length, target_ulong type)
+{
+  while (qsim_icount == 0) {
+    swapcontext(&qemu_context, &main_context);
+  }
+
+  qsim_eip = vaddr;
+
+  qsim_icount--;
+
+  if (qsim_inst_cb != NULL) {
+      ldub_code(vaddr);
+      // Using our own now because qemu_ram_addr_from_host had some weird
+      // results.
+      qsim_phys_addr = qsim_ram_addr_from_host((void *)qsim_host_addr);
+      qsim_inst_cb(qsim_cur_cpu, 
+                   vaddr, 
+                   qsim_phys_addr,
+                   length, 
+                   (uint8_t*)qsim_host_addr,
+                   type
+      );
+  }
+  return 0;
+}
+
+static inline void memop_callback(target_ulong adr, 
+                                  target_ulong size, 
+                                  int type) 
+{
+  if (qsim_mem_cb) {
+    __ldb_mmu(adr, 0);
+    qsim_phys_addr = qsim_ram_addr_from_host((void *)qsim_host_addr);
+    qsim_mem_cb(qsim_cur_cpu, adr, qsim_phys_addr, size, type);
+  }
+}
+
+target_ulong helper_store_callback(target_ulong vaddr, 
+                                   target_ulong size, 
+                                   target_ulong data) 
+{
+  memop_callback(vaddr, size, 1);
+  return 0;
+}
+
+target_ulong helper_load_callback(target_ulong vaddr, target_ulong size) 
+{
+  memop_callback(vaddr, size, 0);
+  return 0;
+}
+
+uint8_t mem_rd(uint64_t paddr) {
+  return ldub_phys(paddr); // ldub_kernel(vaddr)*/0;
+}
+
+void mem_wr(uint64_t paddr, uint8_t value) {
+  stb_phys(paddr, value);
+}
+
+uint8_t mem_rd_virt(uint64_t vaddr) {
+  // This is known to fail on guest operating systems that support the NX bit.
+  return ldub_code(vaddr);
+}
+
+void mem_wr_virt(uint64_t vaddr, uint8_t value) {
+  // This is known to fail on guest operating systems that support the NX bit.
+  ldub_code(vaddr); // discard result but get the host address
+  (*(uint8_t *)qsim_host_addr) = value;
+}
+
+target_ulong helper_reg_read_callback(target_ulong reg, target_ulong size) {
+  if (qsim_reg_cb) qsim_reg_cb(qsim_cur_cpu, reg, size, 0);
+  return 0;
+}
+
+target_ulong helper_reg_write_callback(target_ulong reg, target_ulong size) {
+  if (qsim_reg_cb) qsim_reg_cb(qsim_cur_cpu, reg, size, 1);
+  return 0;
+}
+
+uint64_t get_reg(enum regs r) {
+  switch (r) {
+  case QSIM_RAX:    return first_cpu->regs[R_EAX];
+  case QSIM_RCX:    return first_cpu->regs[R_ECX];
+  case QSIM_RDX:    return first_cpu->regs[R_EDX];
+  case QSIM_RBX:    return first_cpu->regs[R_EBX];
+  case QSIM_RSP:    return first_cpu->regs[R_ESP];
+  case QSIM_RBP:    return first_cpu->regs[R_EBP];
+  case QSIM_RSI:    return first_cpu->regs[R_ESI];
+  case QSIM_RDI:    return first_cpu->regs[R_EDI];
+  case QSIM_ES :    return first_cpu->segs[R_ES ].selector;
+  case QSIM_ESB:    return first_cpu->segs[R_ES ].base;
+  case QSIM_ESL:    return first_cpu->segs[R_ES ].limit;
+  case QSIM_ESF:    return first_cpu->segs[R_ES ].flags;
+  case QSIM_CS :    return first_cpu->segs[R_CS ].selector;
+  case QSIM_CSB:    return first_cpu->segs[R_CS ].base;
+  case QSIM_CSL:    return first_cpu->segs[R_CS ].limit;
+  case QSIM_CSF:    return first_cpu->segs[R_CS ].flags;
+  case QSIM_SS :    return first_cpu->segs[R_SS ].selector;
+  case QSIM_SSB:    return first_cpu->segs[R_SS ].base;
+  case QSIM_SSL:    return first_cpu->segs[R_SS ].limit;
+  case QSIM_SSF:    return first_cpu->segs[R_SS ].flags;
+  case QSIM_DS :    return first_cpu->segs[R_DS ].selector;
+  case QSIM_DSB:    return first_cpu->segs[R_DS ].base;
+  case QSIM_DSL:    return first_cpu->segs[R_DS ].limit;
+  case QSIM_DSF:    return first_cpu->segs[R_DS ].flags;
+  case QSIM_FS :    return first_cpu->segs[R_FS ].selector;
+  case QSIM_FSB:    return first_cpu->segs[R_FS ].base;
+  case QSIM_FSL:    return first_cpu->segs[R_FS ].limit;
+  case QSIM_FSF:    return first_cpu->segs[R_FS ].flags;
+  case QSIM_GS :    return first_cpu->segs[R_GS ].selector;
+  case QSIM_GSB:    return first_cpu->segs[R_GS ].base;
+  case QSIM_GSL:    return first_cpu->segs[R_GS ].limit;
+  case QSIM_GSF:    return first_cpu->segs[R_GS ].flags;
+  case QSIM_RIP:    return qsim_eip;
+  case QSIM_CR0:    return first_cpu->cr  [0    ];
+  case QSIM_CR2:    return first_cpu->cr  [2    ];
+  case QSIM_CR3:    return first_cpu->cr  [3    ];
+  case QSIM_CR4:    return first_cpu->cr  [4    ];
+  case QSIM_RFLAGS: { uint64_t r14_val = env, rval;
+                      env = first_cpu; 
+                      rval = compute_eflags();
+                      env = r14_val;
+                      return rval; }
+  case QSIM_GDTB:   return first_cpu->gdt.base;
+  case QSIM_IDTB:   return first_cpu->idt.base;
+  case QSIM_GDTL:   return first_cpu->gdt.limit;
+  case QSIM_IDTL:   return first_cpu->idt.limit;
+  case QSIM_TR:     return first_cpu->tr.selector;
+  case QSIM_TRB:    return first_cpu->tr.base;
+  case QSIM_TRL:    return first_cpu->tr.limit;
+  case QSIM_TRF:    return first_cpu->tr.flags;
+  case QSIM_LDT:    return first_cpu->ldt.selector;
+  case QSIM_LDTB:   return first_cpu->ldt.base;
+  case QSIM_LDTL:   return first_cpu->ldt.limit;
+  case QSIM_LDTF:   return first_cpu->ldt.flags;
+  case QSIM_DR6:    return first_cpu->dr[6];
+  case QSIM_DR7:    return first_cpu->dr[7];
+  case QSIM_HFLAGS: return first_cpu->hflags;
+  case QSIM_HFLAGS2:return first_cpu->hflags2;
+  case QSIM_SE_CS:  return first_cpu->sysenter_cs;
+  case QSIM_SE_SP:  return first_cpu->sysenter_esp;
+  case QSIM_SE_IP:  return first_cpu->sysenter_eip;
+  default       :   return 0xbadbadbadbadbadbULL;
+  }
+} 
+
+static inline void qsim_update_seg(int seg) {
+  cpu_x86_load_seg_cache(first_cpu, seg, 
+                         first_cpu->segs[seg].selector,
+                         first_cpu->segs[seg].base,
+                         first_cpu->segs[seg].limit,
+                         first_cpu->segs[seg].flags);
+}
+
+void set_reg(enum regs r, uint64_t val) {
+  uint64_t r14_val = env;
+
+  switch (r) {
+  case QSIM_RAX:    first_cpu->regs[R_EAX]          = val;      break;
+  case QSIM_RCX:    first_cpu->regs[R_ECX]          = val;      break;
+  case QSIM_RDX:    first_cpu->regs[R_EDX]          = val;      break;
+  case QSIM_RBX:    first_cpu->regs[R_EBX]          = val;      break;
+  case QSIM_RSP:    first_cpu->regs[R_ESP]          = val;      break;
+  case QSIM_RBP:    first_cpu->regs[R_EBP]          = val;      break;
+  case QSIM_RSI:    first_cpu->regs[R_ESI]          = val;      break;
+  case QSIM_RDI:    first_cpu->regs[R_EDI]          = val;      break;
+  case QSIM_ES :    first_cpu->segs[R_ES ].selector = val;      break;
+  case QSIM_ESB:    first_cpu->segs[R_ES ].base     = val;      break;
+  case QSIM_ESL:    first_cpu->segs[R_ES ].limit    = val;      break;
+  case QSIM_ESF:    first_cpu->segs[R_ES ].flags    = val;
+                    qsim_update_seg(R_ES);                      break;
+  case QSIM_CS :    first_cpu->segs[R_CS ].selector = val;
+                    first_cpu->segs[R_CS ].base     = val << 4; break;
+  case QSIM_CSB:    first_cpu->segs[R_CS ].base     = val;      break;
+  case QSIM_CSL:    first_cpu->segs[R_CS ].limit    = val;      break;
+  case QSIM_CSF:    first_cpu->segs[R_CS ].flags    = val;
+                    qsim_update_seg(R_CS);                      break;
+  case QSIM_SS :    first_cpu->segs[R_SS ].selector = val;
+                    first_cpu->segs[R_SS ].base     = val << 4; break;
+  case QSIM_SSB:    first_cpu->segs[R_SS ].base     = val;      break;
+  case QSIM_SSL:    first_cpu->segs[R_SS ].limit    = val;      break;
+  case QSIM_SSF:    first_cpu->segs[R_SS ].flags    = val;
+                    qsim_update_seg(R_SS);                      break;
+  case QSIM_DS :    first_cpu->segs[R_DS ].selector = val;
+                    first_cpu->segs[R_DS ].base     = val << 4; break;
+  case QSIM_DSB:    first_cpu->segs[R_DS ].base     = val;      break;
+  case QSIM_DSL:    first_cpu->segs[R_DS ].limit    = val;      break;
+  case QSIM_DSF:    first_cpu->segs[R_DS ].flags    = val;
+                    qsim_update_seg(R_DS);                      break;
+  case QSIM_FS :    first_cpu->segs[R_FS ].selector = val;
+                    first_cpu->segs[R_FS ].base     = val << 4; break;
+  case QSIM_FSB:    first_cpu->segs[R_FS ].base     = val;      break;
+  case QSIM_FSL:    first_cpu->segs[R_FS ].limit    = val;      break;
+  case QSIM_FSF:    first_cpu->segs[R_FS ].flags    = val;
+                    qsim_update_seg(R_FS);                      break;
+  case QSIM_GS :    first_cpu->segs[R_GS ].selector = val;
+                    first_cpu->segs[R_GS ].base     = val << 4; break;
+  case QSIM_GSB:    first_cpu->segs[R_GS ].base     = val;      break;
+  case QSIM_GSL:    first_cpu->segs[R_GS ].limit    = val;      break;
+  case QSIM_GSF:    first_cpu->segs[R_GS ].flags    = val;
+                    qsim_update_seg(R_GS);                      break;
+  case QSIM_RIP:    first_cpu->eip                  = val;      break;
+  case QSIM_CR0:    env = first_cpu;
+                    helper_write_crN(0, val);                   break;
+  case QSIM_CR2:    env = first_cpu; 
+                    helper_write_crN(2, val);                   break;
+  case QSIM_CR3:    env = first_cpu;
+                    helper_write_crN(3, val);                   break;
+  case QSIM_CR4:    env = first_cpu;
+                    helper_write_crN(4, val);                   break;
+  case QSIM_GDTB:   first_cpu->gdt.base             = val;      break;
+  case QSIM_GDTL:   first_cpu->gdt.limit            = val;      break;
+  case QSIM_IDTB:   first_cpu->idt.base             = val;      break;
+  case QSIM_IDTL:   first_cpu->idt.limit            = val;      break;
+  case QSIM_RFLAGS: env = first_cpu;
+                    load_eflags(val,
+                      ~(CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C | DF_MASK));
+                                                                break;
+  case QSIM_TR:     first_cpu->tr.selector          = val;      break;
+  case QSIM_TRB:    first_cpu->tr.base              = val;      break;
+  case QSIM_TRL:    first_cpu->tr.limit             = val;      break;
+  case QSIM_TRF:    first_cpu->tr.flags             = val;      break;
+  case QSIM_LDT:    first_cpu->ldt.selector         = val;      break;
+  case QSIM_LDTB:   first_cpu->ldt.base             = val;      break;
+  case QSIM_LDTL:   first_cpu->ldt.limit            = val;      break;
+  case QSIM_LDTF:   first_cpu->ldt.flags            = val;      break;
+  case QSIM_DR6:    first_cpu->dr[6]                = val;      break;
+  case QSIM_DR7:    first_cpu->dr[7]                = val;      break;
+  case QSIM_HFLAGS: first_cpu->hflags               = val;      break;
+  case QSIM_HFLAGS2:first_cpu->hflags2              = val;      break;
+  case QSIM_SE_CS:  first_cpu->sysenter_cs          = val;      break;
+  case QSIM_SE_SP:  first_cpu->sysenter_esp         = val;      break;
+  case QSIM_SE_IP:  first_cpu->sysenter_eip         = val;      break;
+  }
+  env = r14_val;
+}
diff -r -u qemu-0.12.3/target-i386/translate.c qemu-0.12.3-qsim/target-i386/translate.c
--- qemu-0.12.3/target-i386/translate.c	2010-02-23 15:54:38.000000000 -0500
+++ qemu-0.12.3-qsim/target-i386/translate.c	2012-02-09 03:07:37.000000000 -0500
@@ -5,7 +5,7 @@
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
+5B * License as published by the Free Software Foundation; either
  * version 2 of the License, or (at your option) any later version.
  *
  * This library is distributed in the hope that it will be useful,
@@ -58,6 +58,62 @@
 
 //#define MACRO_TEST   1
 
+TCGv_i64 hret, a_;
+uint64_t *itype_arg;
+
+#define QSIM_STORE(name, bytes, d, a, i)                        \
+   (hret = tcg_temp_new_i64(),                                 	\
+   tcg_gen_qemu_##name(d, a, i),                                \
+   gen_helper_store_callback(hret, a, tcg_const_i64(bytes), d), \
+   tcg_temp_free_i64(hret)                                      )
+
+/* The qemu_ld has to be performed twice, once before and once after the
+ * callback. This has unfortunate performance penalties, but this allows the
+ * callback to modify the value being read and keeps the callback itself from
+ * causing page faults.
+ */
+#define QSIM_LOAD(name, bytes, d, a, i)                       \
+  (hret = tcg_temp_new_i64(),                                 \
+   a_ = tcg_temp_new_i64(),                                   \
+   tcg_gen_qemu_##name(d, a, i),                              \
+   gen_helper_load_callback(hret, a, tcg_const_i64(bytes)),   \
+   tcg_gen_qemu_##name(d, a, i),                              \
+   tcg_temp_free_i64(hret)                                    )
+
+#define QSIM_REG_READ(reg, size)                                              \
+  (hret = tcg_temp_new_i64(),                                                 \
+   gen_helper_reg_read_callback(hret,tcg_const_i64(reg),tcg_const_i64(size)), \
+    tcg_temp_free_i64(hret)                                                   )
+
+#define QSIM_REG_WRITE(reg, size)                                             \
+  (hret = tcg_temp_new_i64(),                                                 \
+   gen_helper_reg_write_callback(hret,tcg_const_i64(reg),tcg_const_i64(size)),\
+   tcg_temp_free_i64(hret)                                                    )
+
+#define tcg_gen_qemu_ld8u(dst, addr, idx) \
+    QSIM_LOAD(ld8u, 1, dst, addr, idx)
+#define tcg_gen_qemu_ld8s(dst, addr, idx) \
+    QSIM_LOAD(ld8s, 1, dst, addr, idx)
+#define tcg_gen_qemu_ld16u(dst, addr, idx) \
+    QSIM_LOAD(ld16u, 2, dst, addr, idx)
+#define tcg_gen_qemu_ld16s(dst, addr, idx) \
+    QSIM_LOAD(ld16s, 2, dst, addr, idx)
+#define tcg_gen_qemu_ld32u(dst, addr, idx) \
+    QSIM_LOAD(ld32u, 4, dst, addr, idx)
+#define tcg_gen_qemu_ld32s(dst, addr, idx) \
+    QSIM_LOAD(ld32s, 4, dst, addr, idx)
+#define tcg_gen_qemu_ld64(dst, addr, idx) \
+    QSIM_LOAD(ld64, 8, dst, addr, idx)
+
+#define tcg_gen_qemu_st8(data, addr, idx) \
+    QSIM_STORE(st8, 1, data, addr, idx)
+#define tcg_gen_qemu_st16(data, addr, idx) \
+    QSIM_STORE(st16, 2, data, addr, idx)
+#define tcg_gen_qemu_st32(data, addr, idx) \
+    QSIM_STORE(st32, 4, data, addr, idx)
+#define tcg_gen_qemu_st64(data, addr, idx) \
+    QSIM_STORE(st64, 8, data, addr, idx)
+
 /* global register indexes */
 static TCGv_ptr cpu_env;
 static TCGv cpu_A0, cpu_cc_src, cpu_cc_dst, cpu_cc_tmp;
@@ -272,10 +328,12 @@
 
 static inline void gen_op_mov_reg_v(int ot, int reg, TCGv t0)
 {
+    int ot_size;
     TCGv tmp;
 
     switch(ot) {
     case OT_BYTE:
+        ot_size = 1;
         tmp = tcg_temp_new();
         tcg_gen_ext8u_tl(tmp, t0);
         if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {
@@ -289,6 +347,7 @@
         tcg_temp_free(tmp);
         break;
     case OT_WORD:
+        ot_size = 2;
         tmp = tcg_temp_new();
         tcg_gen_ext16u_tl(tmp, t0);
         tcg_gen_andi_tl(cpu_regs[reg], cpu_regs[reg], ~0xffff);
@@ -297,16 +356,20 @@
         break;
     default: /* XXX this shouldn't be reached;  abort? */
     case OT_LONG:
+        ot_size = 4;
         /* For x86_64, this sets the higher half of register to zero.
            For i386, this is equivalent to a mov. */
         tcg_gen_ext32u_tl(cpu_regs[reg], t0);
         break;
 #ifdef TARGET_X86_64
     case OT_QUAD:
+        ot_size = 8;
         tcg_gen_mov_tl(cpu_regs[reg], t0);
         break;
 #endif
     }
+
+    QSIM_REG_WRITE(reg, ot_size);
 }
 
 static inline void gen_op_mov_reg_T0(int ot, int reg)
@@ -343,6 +406,8 @@
         break;
 #endif
     }
+
+    QSIM_REG_WRITE(reg, (2<<size));
 }
 
 static inline void gen_op_mov_v_reg(int ot, TCGv t0, int reg)
@@ -361,6 +426,16 @@
         tcg_gen_mov_tl(t0, cpu_regs[reg]);
         break;
     }
+
+    int ot_size;
+    switch(ot) {
+    case OT_BYTE: ot_size = 1; break;
+    case OT_WORD: ot_size = 2; break;
+    case OT_LONG: ot_size = 4; break;
+    case OT_QUAD: ot_size = 8; break;
+    };
+
+    QSIM_REG_READ(reg, ot_size);
 }
 
 static inline void gen_op_mov_TN_reg(int ot, int t_index, int reg)
@@ -371,6 +446,7 @@
 static inline void gen_op_movl_A0_reg(int reg)
 {
     tcg_gen_mov_tl(cpu_A0, cpu_regs[reg]);
+    QSIM_REG_READ(reg, 4);
 }
 
 static inline void gen_op_addl_A0_im(int32_t val)
@@ -405,11 +481,14 @@
 
 static inline void gen_op_jmp_T0(void)
 {
+    *itype_arg = QSIM_INST_BR;
     tcg_gen_st_tl(cpu_T[0], cpu_env, offsetof(CPUState, eip));
 }
 
 static inline void gen_op_add_reg_im(int size, int reg, int32_t val)
 {
+    QSIM_REG_READ(reg, (2<<size));
+
     switch(size) {
     case 0:
         tcg_gen_addi_tl(cpu_tmp0, cpu_regs[reg], val);
@@ -430,10 +509,14 @@
         break;
 #endif
     }
+
+    QSIM_REG_WRITE(reg, (2<<size));
 }
 
 static inline void gen_op_add_reg_T0(int size, int reg)
 {
+    QSIM_REG_READ(reg, (2<<size));
+
     switch(size) {
     case 0:
         tcg_gen_add_tl(cpu_tmp0, cpu_regs[reg], cpu_T[0]);
@@ -454,6 +537,8 @@
         break;
 #endif
     }
+
+    QSIM_REG_WRITE(reg, (2<<size));
 }
 
 static inline void gen_op_set_cc_op(int32_t val)
@@ -463,6 +548,7 @@
 
 static inline void gen_op_addl_A0_reg_sN(int shift, int reg)
 {
+    QSIM_REG_READ(reg, 4);
     tcg_gen_mov_tl(cpu_tmp0, cpu_regs[reg]);
     if (shift != 0)
         tcg_gen_shli_tl(cpu_tmp0, cpu_tmp0, shift);
@@ -501,11 +587,13 @@
 static inline void gen_op_movq_A0_reg(int reg)
 {
     tcg_gen_mov_tl(cpu_A0, cpu_regs[reg]);
+    QSIM_REG_READ(reg, 8);
 }
 
 static inline void gen_op_addq_A0_reg_sN(int shift, int reg)
 {
     tcg_gen_mov_tl(cpu_tmp0, cpu_regs[reg]);
+    QSIM_REG_READ(reg, 8);
     if (shift != 0)
         tcg_gen_shli_tl(cpu_tmp0, cpu_tmp0, shift);
     tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_tmp0);
@@ -706,14 +794,18 @@
 static inline void gen_op_jnz_ecx(int size, int label1)
 {
     tcg_gen_mov_tl(cpu_tmp0, cpu_regs[R_ECX]);
+    QSIM_REG_READ(R_ECX, 4);
     gen_extu(size + 1, cpu_tmp0);
+    QSIM_REG_READ(QSIM_FLAG_ZF, 0);
     tcg_gen_brcondi_tl(TCG_COND_NE, cpu_tmp0, 0, label1);
 }
 
 static inline void gen_op_jz_ecx(int size, int label1)
 {
     tcg_gen_mov_tl(cpu_tmp0, cpu_regs[R_ECX]);
+    QSIM_REG_READ(R_ECX, 4);
     gen_extu(size + 1, cpu_tmp0);
+    QSIM_REG_READ(QSIM_FLAG_ZF, 0);
     tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_tmp0, 0, label1);
 }
 
@@ -949,6 +1041,29 @@
     inv = b & 1;
     jcc_op = (b >> 1) & 7;
 
+    /* Generate the QSIM register read for the flag read. */
+    switch(jcc_op) {
+    case JCC_O:  QSIM_REG_READ(QSIM_FLAG_OF, 0); break;
+
+    case JCC_B:  QSIM_REG_READ(QSIM_FLAG_CF, 0); break;
+
+    case JCC_Z:  QSIM_REG_READ(QSIM_FLAG_ZF, 0); break;
+
+    case JCC_BE: QSIM_REG_READ(QSIM_FLAG_CF|
+                               QSIM_FLAG_ZF, 0); break;
+
+    case JCC_S:  QSIM_REG_READ(QSIM_FLAG_SF, 0); break;
+
+    case JCC_P:  QSIM_REG_READ(QSIM_FLAG_PF, 0); break;
+
+    case JCC_L:  QSIM_REG_READ(QSIM_FLAG_OF|
+                               QSIM_FLAG_SF, 0); break;
+
+    case JCC_LE: QSIM_REG_READ(QSIM_FLAG_OF|
+                               QSIM_FLAG_SF|
+                               QSIM_FLAG_ZF, 0); break;
+    }
+
     switch(cc_op) {
         /* we optimize the cmp/jcc case */
     case CC_OP_SUBB:
@@ -1278,14 +1393,22 @@
 static void gen_helper_fp_arith_ST0_FT0(int op)
 {
     switch (op) {
-    case 0: gen_helper_fadd_ST0_FT0(); break;
-    case 1: gen_helper_fmul_ST0_FT0(); break;
-    case 2: gen_helper_fcom_ST0_FT0(); break;
-    case 3: gen_helper_fcom_ST0_FT0(); break;
-    case 4: gen_helper_fsub_ST0_FT0(); break;
-    case 5: gen_helper_fsubr_ST0_FT0(); break;
-    case 6: gen_helper_fdiv_ST0_FT0(); break;
-    case 7: gen_helper_fdivr_ST0_FT0(); break;
+    case 0: *itype_arg = QSIM_INST_FPBASIC;
+            gen_helper_fadd_ST0_FT0(); break;
+    case 1: *itype_arg = QSIM_INST_FPMUL;
+            gen_helper_fmul_ST0_FT0(); break;
+    case 2: *itype_arg = QSIM_INST_FPBASIC;
+            gen_helper_fcom_ST0_FT0(); break;
+    case 3: *itype_arg = QSIM_INST_FPBASIC;
+            gen_helper_fcom_ST0_FT0(); break;
+    case 4: *itype_arg = QSIM_INST_FPBASIC;
+            gen_helper_fsub_ST0_FT0(); break;
+    case 5: *itype_arg = QSIM_INST_FPBASIC;
+            gen_helper_fsubr_ST0_FT0(); break;
+    case 6: *itype_arg = QSIM_INST_FPDIV;
+            gen_helper_fdiv_ST0_FT0(); break;
+    case 7: *itype_arg = QSIM_INST_FPDIV;
+            gen_helper_fdivr_ST0_FT0(); break;
     }
 }
 
@@ -1294,18 +1417,25 @@
 {
     TCGv_i32 tmp = tcg_const_i32(opreg);
     switch (op) {
-    case 0: gen_helper_fadd_STN_ST0(tmp); break;
-    case 1: gen_helper_fmul_STN_ST0(tmp); break;
-    case 4: gen_helper_fsubr_STN_ST0(tmp); break;
-    case 5: gen_helper_fsub_STN_ST0(tmp); break;
-    case 6: gen_helper_fdivr_STN_ST0(tmp); break;
-    case 7: gen_helper_fdiv_STN_ST0(tmp); break;
+    case 0: *itype_arg = QSIM_INST_FPBASIC;
+            gen_helper_fadd_STN_ST0(tmp); break;
+    case 1: *itype_arg = QSIM_INST_FPMUL;
+            gen_helper_fmul_STN_ST0(tmp); break;
+    case 4: *itype_arg = QSIM_INST_FPBASIC;
+            gen_helper_fsubr_STN_ST0(tmp); break;
+    case 5: *itype_arg = QSIM_INST_FPBASIC;
+            gen_helper_fsub_STN_ST0(tmp); break;
+    case 6: *itype_arg = QSIM_INST_FPDIV;
+            gen_helper_fdivr_STN_ST0(tmp); break;
+    case 7: *itype_arg = QSIM_INST_FPDIV;
+            gen_helper_fdiv_STN_ST0(tmp); break;
     }
 }
 
 /* if d == OR_TMP0, it means memory operand (address in A0) */
 static void gen_op(DisasContext *s1, int op, int ot, int d)
 {
+    *itype_arg = QSIM_INST_INTBASIC;
     if (d != OR_TMP0) {
         gen_op_mov_TN_reg(ot, 0, d);
     } else {
@@ -1313,6 +1443,7 @@
     }
     switch(op) {
     case OP_ADCL:
+        QSIM_REG_READ(QSIM_FLAG_CF, 0);
         if (s1->cc_op != CC_OP_DYNAMIC)
             gen_op_set_cc_op(s1->cc_op);
         gen_compute_eflags_c(cpu_tmp4);
@@ -1328,8 +1459,10 @@
         tcg_gen_shli_i32(cpu_tmp2_i32, cpu_tmp2_i32, 2);
         tcg_gen_addi_i32(cpu_cc_op, cpu_tmp2_i32, CC_OP_ADDB + ot);
         s1->cc_op = CC_OP_DYNAMIC;
+        QSIM_REG_WRITE(QSIM_FLAG_ALL, 0);
         break;
     case OP_SBBL:
+        QSIM_REG_READ(QSIM_FLAG_CF, 0);
         if (s1->cc_op != CC_OP_DYNAMIC)
             gen_op_set_cc_op(s1->cc_op);
         gen_compute_eflags_c(cpu_tmp4);
@@ -1345,6 +1478,7 @@
         tcg_gen_shli_i32(cpu_tmp2_i32, cpu_tmp2_i32, 2);
         tcg_gen_addi_i32(cpu_cc_op, cpu_tmp2_i32, CC_OP_SUBB + ot);
         s1->cc_op = CC_OP_DYNAMIC;
+        QSIM_REG_WRITE(QSIM_FLAG_ALL, 0);
         break;
     case OP_ADDL:
         gen_op_addl_T0_T1();
@@ -1354,6 +1488,7 @@
             gen_op_st_T0_A0(ot + s1->mem_index);
         gen_op_update2_cc();
         s1->cc_op = CC_OP_ADDB + ot;
+        QSIM_REG_WRITE(QSIM_FLAG_ALL, 0);
         break;
     case OP_SUBL:
         tcg_gen_sub_tl(cpu_T[0], cpu_T[0], cpu_T[1]);
@@ -1363,6 +1498,7 @@
             gen_op_st_T0_A0(ot + s1->mem_index);
         gen_op_update2_cc();
         s1->cc_op = CC_OP_SUBB + ot;
+        QSIM_REG_WRITE(QSIM_FLAG_ALL, 0);
         break;
     default:
     case OP_ANDL:
@@ -1373,6 +1509,7 @@
             gen_op_st_T0_A0(ot + s1->mem_index);
         gen_op_update1_cc();
         s1->cc_op = CC_OP_LOGICB + ot;
+        QSIM_REG_WRITE(QSIM_FLAG_LOG, 0);
         break;
     case OP_ORL:
         tcg_gen_or_tl(cpu_T[0], cpu_T[0], cpu_T[1]);
@@ -1382,6 +1519,7 @@
             gen_op_st_T0_A0(ot + s1->mem_index);
         gen_op_update1_cc();
         s1->cc_op = CC_OP_LOGICB + ot;
+        QSIM_REG_WRITE(QSIM_FLAG_LOG, 0);
         break;
     case OP_XORL:
         tcg_gen_xor_tl(cpu_T[0], cpu_T[0], cpu_T[1]);
@@ -1391,10 +1529,12 @@
             gen_op_st_T0_A0(ot + s1->mem_index);
         gen_op_update1_cc();
         s1->cc_op = CC_OP_LOGICB + ot;
+        QSIM_REG_WRITE(QSIM_FLAG_LOG, 0);
         break;
     case OP_CMPL:
         gen_op_cmpl_T0_T1_cc();
         s1->cc_op = CC_OP_SUBB + ot;
+        QSIM_REG_WRITE(QSIM_FLAG_ALL, 0);
         break;
     }
 }
@@ -1421,6 +1561,7 @@
         gen_op_st_T0_A0(ot + s1->mem_index);
     gen_compute_eflags_c(cpu_cc_src);
     tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);
+    QSIM_REG_WRITE(QSIM_FLAG_INC, 0);
 }
 
 static void gen_shift_rm_T1(DisasContext *s, int ot, int op1, 
@@ -1909,57 +2050,74 @@
 
 static void gen_shift(DisasContext *s1, int op, int ot, int d, int s)
 {
+    *itype_arg = QSIM_INST_INTBASIC;
     if (s != OR_TMP1)
         gen_op_mov_TN_reg(ot, 1, s);
     switch(op) {
     case OP_ROL:
         gen_rot_rm_T1(s1, ot, d, 0);
+        QSIM_REG_WRITE(QSIM_FLAG_ROT, 0);
         break;
     case OP_ROR:
         gen_rot_rm_T1(s1, ot, d, 1);
+        QSIM_REG_WRITE(QSIM_FLAG_ROT, 0);
         break;
     case OP_SHL:
     case OP_SHL1:
         gen_shift_rm_T1(s1, ot, d, 0, 0);
+        QSIM_REG_WRITE(QSIM_FLAG_ALL, 0);
         break;
     case OP_SHR:
         gen_shift_rm_T1(s1, ot, d, 1, 0);
+        QSIM_REG_WRITE(QSIM_FLAG_ALL, 0);
         break;
     case OP_SAR:
         gen_shift_rm_T1(s1, ot, d, 1, 1);
+        QSIM_REG_WRITE(QSIM_FLAG_ALL, 0);
         break;
     case OP_RCL:
+        QSIM_REG_READ(QSIM_FLAG_CF, 0);
         gen_rotc_rm_T1(s1, ot, d, 0);
+        QSIM_REG_WRITE(QSIM_FLAG_ALL, 0);
         break;
     case OP_RCR:
+        QSIM_REG_READ(QSIM_FLAG_CF, 0);
         gen_rotc_rm_T1(s1, ot, d, 1);
+        QSIM_REG_WRITE(QSIM_FLAG_ROT, 0);
         break;
     }
 }
 
 static void gen_shifti(DisasContext *s1, int op, int ot, int d, int c)
 {
+  *itype_arg = QSIM_INST_INTBASIC;
     switch(op) {
     case OP_ROL:
         gen_rot_rm_im(s1, ot, d, c, 0);
+        QSIM_REG_WRITE(QSIM_FLAG_ROT, 0);
         break;
     case OP_ROR:
         gen_rot_rm_im(s1, ot, d, c, 1);
+        QSIM_REG_WRITE(QSIM_FLAG_ROT, 0);
         break;
     case OP_SHL:
     case OP_SHL1:
         gen_shift_rm_im(s1, ot, d, c, 0, 0);
+        QSIM_REG_WRITE(QSIM_FLAG_ALL, 0);
         break;
     case OP_SHR:
         gen_shift_rm_im(s1, ot, d, c, 1, 0);
+        QSIM_REG_WRITE(QSIM_FLAG_ALL, 0);
         break;
     case OP_SAR:
         gen_shift_rm_im(s1, ot, d, c, 1, 1);
+        QSIM_REG_WRITE(QSIM_FLAG_ALL, 0);
         break;
     default:
         /* currently not optimized */
         gen_op_movl_T1_im(c);
         gen_shift(s1, op, ot, d, OR_TMP1);
+        QSIM_REG_WRITE(QSIM_FLAG_ALL, 0);
         break;
     }
 }
@@ -2310,6 +2468,8 @@
 {
     int l1, l2, cc_op;
 
+    *itype_arg = QSIM_INST_BR;
+
     cc_op = s->cc_op;
     if (s->cc_op != CC_OP_DYNAMIC) {
         gen_op_set_cc_op(s->cc_op);
@@ -2451,6 +2611,7 @@
 /* generate a push. It depends on ss32, addseg and dflag */
 static void gen_push_T0(DisasContext *s)
 {
+    *itype_arg = QSIM_INST_STACK;
 #ifdef TARGET_X86_64
     if (CODE64(s)) {
         gen_op_movq_A0_reg(R_ESP);
@@ -2492,6 +2653,7 @@
 /* slower version for T1, only used for call Ev */
 static void gen_push_T1(DisasContext *s)
 {
+    *itype_arg = QSIM_INST_STACK;
 #ifdef TARGET_X86_64
     if (CODE64(s)) {
         gen_op_movq_A0_reg(R_ESP);
@@ -2531,6 +2693,7 @@
 /* two step pop is necessary for precise exceptions */
 static void gen_pop_T0(DisasContext *s)
 {
+    *itype_arg = QSIM_INST_STACK;
 #ifdef TARGET_X86_64
     if (CODE64(s)) {
         gen_op_movq_A0_reg(R_ESP);
@@ -2552,6 +2715,7 @@
 
 static void gen_pop_update(DisasContext *s)
 {
+    *itype_arg = QSIM_INST_STACK; 
 #ifdef TARGET_X86_64
     if (CODE64(s) && s->dflag) {
         gen_stack_update(s, 8);
@@ -2564,6 +2728,7 @@
 
 static void gen_stack_A0(DisasContext *s)
 {
+    *itype_arg = QSIM_INST_STACK;
     gen_op_movl_A0_reg(R_ESP);
     if (!s->ss32)
         gen_op_andl_A0_ffff();
@@ -2575,6 +2740,7 @@
 /* NOTE: wrap around in 16 bit not fully handled */
 static void gen_pusha(DisasContext *s)
 {
+    *itype_arg = QSIM_INST_STACK;
     int i;
     gen_op_movl_A0_reg(R_ESP);
     gen_op_addl_A0_im(-16 <<  s->dflag);
@@ -2594,6 +2760,7 @@
 /* NOTE: wrap around in 16 bit not fully handled */
 static void gen_popa(DisasContext *s)
 {
+    *itype_arg = QSIM_INST_STACK;
     int i;
     gen_op_movl_A0_reg(R_ESP);
     if (!s->ss32)
@@ -2616,6 +2783,7 @@
 static void gen_enter(DisasContext *s, int esp_addend, int level)
 {
     int ot, opsize;
+    *itype_arg = QSIM_INST_STACK;
 
     level &= 0x1f;
 #ifdef TARGET_X86_64
@@ -2681,6 +2849,9 @@
 static void gen_interrupt(DisasContext *s, int intno,
                           target_ulong cur_eip, target_ulong next_eip)
 {
+    *itype_arg = QSIM_INST_TRAP;
+    QSIM_REG_READ(QSIM_FLAG_ALL, 0);
+
     if (s->cc_op != CC_OP_DYNAMIC)
         gen_op_set_cc_op(s->cc_op);
     gen_jmp_im(cur_eip);
@@ -2739,6 +2910,7 @@
 
 static void gen_jmp(DisasContext *s, target_ulong eip)
 {
+    *itype_arg = QSIM_INST_BR;
     gen_jmp_tb(s, eip, 0);
 }
 
@@ -4366,6 +4538,8 @@
             gen_op_movl_T1_im(val);
             gen_op_testl_T0_T1_cc();
             s->cc_op = CC_OP_LOGICB + ot;
+            QSIM_REG_WRITE(QSIM_FLAG_ALL, 0);
+            *itype_arg = QSIM_INST_INTBASIC;
             break;
         case 2: /* not */
             tcg_gen_not_tl(cpu_T[0], cpu_T[0]);
@@ -4374,6 +4548,7 @@
             } else {
                 gen_op_mov_reg_T0(ot, rm);
             }
+            *itype_arg = QSIM_INST_INTBASIC;
             break;
         case 3: /* neg */
             tcg_gen_neg_tl(cpu_T[0], cpu_T[0]);
@@ -4384,8 +4559,10 @@
             }
             gen_op_update_neg_cc();
             s->cc_op = CC_OP_SUBB + ot;
+            *itype_arg = QSIM_INST_INTBASIC;
             break;
         case 4: /* mul */
+            *itype_arg = QSIM_INST_INTMUL;
             switch(ot) {
             case OT_BYTE:
                 gen_op_mov_TN_reg(OT_BYTE, 1, R_EAX);
@@ -4452,6 +4629,7 @@
             }
             break;
         case 5: /* imul */
+            *itype_arg = QSIM_INST_INTMUL;
             switch(ot) {
             case OT_BYTE:
                 gen_op_mov_TN_reg(OT_BYTE, 1, R_EAX);
@@ -4522,6 +4700,7 @@
             }
             break;
         case 6: /* div */
+            *itype_arg = QSIM_INST_INTDIV;
             switch(ot) {
             case OT_BYTE:
                 gen_jmp_im(pc_start - s->cs_base);
@@ -4545,6 +4724,7 @@
             }
             break;
         case 7: /* idiv */
+            *itype_arg = QSIM_INST_INTDIV;
             switch(ot) {
             case OT_BYTE:
                 gen_jmp_im(pc_start - s->cs_base);
@@ -4631,6 +4811,7 @@
             gen_push_T1(s);
             gen_op_jmp_T0();
             gen_eob(s);
+            *itype_arg = QSIM_INST_CALL;
             break;
         case 3: /* lcall Ev */
             gen_op_ld_T1_A0(ot + s->mem_index);
@@ -4651,6 +4832,7 @@
                                       tcg_const_i32(dflag), 
                                       tcg_const_i32(s->pc - s->cs_base));
             }
+            *itype_arg = QSIM_INST_CALL;
             gen_eob(s);
             break;
         case 4: /* jmp Ev */
@@ -4676,6 +4858,7 @@
                 gen_op_movl_T0_T1();
                 gen_op_jmp_T0();
             }
+            *itype_arg = QSIM_INST_BR;
             gen_eob(s);
             break;
         case 6: /* push Ev */
@@ -4702,6 +4885,9 @@
         gen_op_mov_TN_reg(ot, 1, reg);
         gen_op_testl_T0_T1_cc();
         s->cc_op = CC_OP_LOGICB + ot;
+
+        QSIM_REG_WRITE(QSIM_FLAG_ALL, 0);
+        *itype_arg = QSIM_INST_INTBASIC;
         break;
 
     case 0xa8: /* test eAX, Iv */
@@ -4716,6 +4902,8 @@
         gen_op_movl_T1_im(val);
         gen_op_testl_T0_T1_cc();
         s->cc_op = CC_OP_LOGICB + ot;
+        QSIM_REG_WRITE(QSIM_FLAG_ALL, 0);
+        *itype_arg = QSIM_INST_INTBASIC;
         break;
 
     case 0x98: /* CWDE/CBW */
@@ -4820,6 +5008,7 @@
         break;
     case 0x1c0:
     case 0x1c1: /* xadd Ev, Gv */
+        if (!(prefixes & PREFIX_LOCK)) gen_helper_lock(); //Is atomic.
         if ((b & 1) == 0)
             ot = OT_BYTE;
         else
@@ -4844,9 +5033,11 @@
         }
         gen_op_update2_cc();
         s->cc_op = CC_OP_ADDB + ot;
+	if (!(prefixes & PREFIX_LOCK)) gen_helper_unlock(); // Is atomic.
         break;
     case 0x1b0:
     case 0x1b1: /* cmpxchg Ev, Gv */
+      if (!(prefixes & PREFIX_LOCK)) gen_helper_lock(); //Is atomic.
         {
             int label1, label2;
             TCGv t0, t1, t2, a0;
@@ -4898,8 +5089,10 @@
             tcg_temp_free(t2);
             tcg_temp_free(a0);
         }
+	if (!(prefixes & PREFIX_LOCK)) gen_helper_unlock(); // Is atomic.
         break;
     case 0x1c7: /* cmpxchg8b */
+      if (!(prefixes & PREFIX_LOCK)) gen_helper_lock(); //Is atomic.
         modrm = ldub_code(s->pc++);
         mod = (modrm >> 6) & 3;
         if ((mod == 3) || ((modrm & 0x38) != 0x8))
@@ -4925,6 +5118,7 @@
             gen_helper_cmpxchg8b(cpu_A0);
         }
         s->cc_op = CC_OP_EFLAGS;
+	if (!(prefixes & PREFIX_LOCK)) gen_helper_unlock(); // Is atomic.
         break;
 
         /**************************/
@@ -6186,6 +6380,7 @@
             gen_op_andl_T0_ffff();
         gen_op_jmp_T0();
         gen_eob(s);
+        *itype_arg = QSIM_INST_RET;
         break;
     case 0xc3: /* ret */
         gen_pop_T0(s);
@@ -6194,6 +6389,7 @@
             gen_op_andl_T0_ffff();
         gen_op_jmp_T0();
         gen_eob(s);
+        *itype_arg = QSIM_INST_RET;
         break;
     case 0xca: /* lret im */
         val = ldsw_code(s->pc);
@@ -6221,6 +6417,7 @@
             /* add stack offset */
             gen_stack_update(s, val + (4 << s->dflag));
         }
+        *itype_arg = QSIM_INST_RET;
         gen_eob(s);
         break;
     case 0xcb: /* lret */
@@ -6247,7 +6444,9 @@
                                       tcg_const_i32(s->pc - s->cs_base));
             s->cc_op = CC_OP_EFLAGS;
         }
+        QSIM_REG_WRITE(QSIM_FLAG_ALL, 0);
         gen_eob(s);
+        *itype_arg = QSIM_INST_RET;
         break;
     case 0xe8: /* call im */
         {
@@ -6265,6 +6464,7 @@
             gen_push_T0(s);
             gen_jmp(s, tval);
         }
+        *itype_arg = QSIM_INST_CALL;
         break;
     case 0x9a: /* lcall im */
         {
@@ -6334,6 +6534,7 @@
         modrm = ldub_code(s->pc++);
         gen_setcc(s, b);
         gen_ldst_modrm(s, modrm, OT_BYTE, OR_TMP0, 1);
+        *itype_arg = QSIM_INST_INTBASIC;
         break;
     case 0x140 ... 0x14f: /* cmov Gv, Ev */
         {
@@ -6375,6 +6576,8 @@
         /************************/
         /* flags */
     case 0x9c: /* pushf */
+        *itype_arg = QSIM_INST_STACK;
+        QSIM_REG_READ(QSIM_FLAG_ALL, 0);
         gen_svm_check_intercept(s, pc_start, SVM_EXIT_PUSHF);
         if (s->vm86 && s->iopl != 3) {
             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
@@ -6386,6 +6589,7 @@
         }
         break;
     case 0x9d: /* popf */
+        *itype_arg = QSIM_INST_STACK;
         gen_svm_check_intercept(s, pc_start, SVM_EXIT_POPF);
         if (s->vm86 && s->iopl != 3) {
             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
@@ -6420,6 +6624,7 @@
             }
             gen_pop_update(s);
             s->cc_op = CC_OP_EFLAGS;
+            QSIM_REG_WRITE(QSIM_FLAG_ALL, 0);
             /* abort translation because TF flag may change */
             gen_jmp_im(s->pc - s->cs_base);
             gen_eob(s);
@@ -6436,8 +6641,10 @@
         tcg_gen_andi_tl(cpu_T[0], cpu_T[0], CC_S | CC_Z | CC_A | CC_P | CC_C);
         tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, cpu_T[0]);
         s->cc_op = CC_OP_EFLAGS;
+        QSIM_REG_WRITE(QSIM_FLAG_ALL&(~QSIM_FLAG_OF), 0);
         break;
     case 0x9f: /* lahf */
+        QSIM_REG_READ(QSIM_FLAG_ALL&(~QSIM_FLAG_OF), 0);
         if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))
             goto illegal_op;
         if (s->cc_op != CC_OP_DYNAMIC)
@@ -6921,6 +7128,7 @@
         }
         gen_jmp_im(pc_start - s->cs_base);
         gen_helper_syscall(tcg_const_i32(s->pc - pc_start));
+        *itype_arg = QSIM_INST_TRAP;
         gen_eob(s);
         break;
     case 0x107: /* sysret */
@@ -6938,6 +7146,7 @@
                 s->cc_op = CC_OP_EFLAGS;
             gen_eob(s);
         }
+        *itype_arg = QSIM_INST_RET;
         break;
 #endif
     case 0x1a2: /* cpuid */
@@ -7848,8 +8057,25 @@
         }
         if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))
             gen_io_start();
+        
+        TCGv_i64 pc_v = tcg_const_i64((uint64_t)pc_ptr);
+        /* Use the "dirty hack" like gen-icount.h to patch the TCG op */
+        uint64_t *ilen_arg = gen_opparam_ptr + 1,
+                 old_pc_ptr = pc_ptr;
+        itype_arg = gen_opparam_ptr + 3;
+
+        TCGv_i64 len_v  = tcg_const_i64(0xdeadbee5),
+                 type_v = tcg_const_i64(0xdeadbeef);
+        *itype_arg = QSIM_INST_NULL;
+        hret = tcg_temp_new_i64();
+        gen_helper_inst_callback(hret, pc_v, len_v, type_v);
+        tcg_temp_free_i64(hret);
+        tcg_temp_free_i64(pc_v);
+        tcg_temp_free_i64(len_v);
+        tcg_temp_free_i64(type_v);
 
         pc_ptr = disas_insn(dc, pc_ptr);
+        *ilen_arg = pc_ptr - old_pc_ptr;
         num_insns++;
         /* stop translation if indicated */
         if (dc->is_jmp)
diff -r -u qemu-0.12.3/vl.c qemu-0.12.3-qsim/vl.c
--- qemu-0.12.3/vl.c	2010-02-23 15:54:38.000000000 -0500
+++ qemu-0.12.3-qsim/vl.c	2012-02-09 05:19:35.000000000 -0500
@@ -91,6 +91,9 @@
 #endif
 #endif
 
+static void qsim_loop_main(void);
+static int qsim_qemu_main(int argc, const char **argv, const char **envp);
+
 #if defined(__OpenBSD__)
 #include <util.h>
 #endif
@@ -168,6 +171,11 @@
 
 #include "qemu-queue.h"
 
+#include "qsim-vm.h"
+#include "vm-func.h"
+
+#include "qsim-context.h"
+
 //#define DEBUG_NET
 //#define DEBUG_SLIRP
 
@@ -293,6 +301,40 @@
     { .driver = "vmware-svga",          .flag = &default_vga       },
 };
 
+#include <pthread.h>
+
+int qsim_vm_id;
+int qsim_cur_cpu;
+
+pthread_rwlock_t *qsim_atomic_lock;
+
+atomic_cb_t qsim_atomic_cb = NULL;
+magic_cb_t  qsim_magic_cb  = NULL;
+int_cb_t    qsim_int_cb    = NULL;
+mem_cb_t    qsim_mem_cb    = NULL;
+inst_cb_t   qsim_inst_cb   = NULL;
+io_cb_t     qsim_io_cb     = NULL;
+reg_cb_t    qsim_reg_cb    = NULL;
+
+
+uint64_t qsim_host_addr;
+uint64_t qsim_phys_addr;
+
+uint8_t         qsim_irq_vec     = 0;
+int             qsim_irq_pending = 0;
+pthread_mutex_t qsim_irq_lock    = PTHREAD_MUTEX_INITIALIZER;
+
+uint64_t    qsim_icount ;
+qsim_ucontext_t  main_context;
+qsim_ucontext_t  qemu_context;
+void       *qemu_stack  ;
+
+qemu_ramdesc_t *qsim_ram;
+int             qsim_qemu_is_slave;
+
+const size_t QEMU_STACK_SIZE = 8*(1<<20);
+
+
 static int default_driver_check(QemuOpts *opts, void *opaque)
 {
     const char *driver = qemu_opt_get(opts, "driver");
@@ -651,6 +693,7 @@
 static void init_get_clock(void)
 {
     use_rt_clock = 0;
+#if 0
 #if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 500000) \
     || defined(__DragonFly__) || defined(__FreeBSD_kernel__)
     {
@@ -660,6 +703,7 @@
         }
     }
 #endif
+#endif
 }
 
 static int64_t get_clock(void)
@@ -910,6 +954,7 @@
 }
 
 static struct qemu_alarm_timer alarm_timers[] = {
+#if 0
 #ifndef _WIN32
 #ifdef __linux__
     {"dynticks", ALARM_FLAG_DYNTICKS, dynticks_start_timer,
@@ -926,6 +971,7 @@
     {"win32", 0, win32_start_timer,
      win32_stop_timer, NULL, &alarm_win32_data},
 #endif
+#endif
     {NULL, }
 };
 
@@ -1189,8 +1235,8 @@
 static void host_alarm_handler(int host_signum)
 #endif
 {
-#if 0
 #define DISP_FREQ 1000
+#if 0
     {
         static int64_t delta_min = INT64_MAX;
         static int64_t delta_max, delta_cum, last_clock, delta, ti;
@@ -1217,27 +1263,29 @@
         }
         last_clock = ti;
     }
-#endif
+
     if (alarm_has_dynticks(alarm_timer) ||
-        (!use_icount &&
-            qemu_timer_expired(active_timers[QEMU_CLOCK_VIRTUAL],
+        (!use_icount /*&&
+	 qemu_timer_expired(active_timers[QEMU_CLOCK_VIRTUAL],
                                qemu_get_clock(vm_clock))) ||
-        qemu_timer_expired(active_timers[QEMU_CLOCK_REALTIME],
-                           qemu_get_clock(rt_clock)) ||
-        qemu_timer_expired(active_timers[QEMU_CLOCK_HOST],
-                           qemu_get_clock(host_clock))) {
-        qemu_event_increment();
+         qemu_timer_expired(active_timers[QEMU_CLOCK_REALTIME],
+	 qemu_get_clock(rt_clock)) ||
+         qemu_timer_expired(active_timers[QEMU_CLOCK_HOST],
+	 qemu_get_clock(host_clock)*/)) {
+      //qemu_event_increment();
         if (alarm_timer) alarm_timer->flags |= ALARM_FLAG_EXPIRED;
 
 #ifndef CONFIG_IOTHREAD
         if (next_cpu) {
             /* stop the currently executing cpu because a timer occured */
-            cpu_exit(next_cpu);
+	    //cpu_exit(next_cpu);
         }
 #endif
         timer_alarm_pending = 1;
-        qemu_notify_event();
+        //qemu_notify_event();
     }
+#endif
+
 }
 
 static int64_t qemu_next_deadline(void)
@@ -1417,7 +1465,7 @@
     act.sa_flags = 0;
     act.sa_handler = host_alarm_handler;
 
-    sigaction(SIGALRM, &act, NULL);
+    /* sigaction(SIGALRM, &act, NULL); */
 
     /* 
      * Initialize ev struct to 0 to avoid valgrind complaining
@@ -1426,7 +1474,7 @@
     memset(&ev, 0, sizeof(ev));
     ev.sigev_value.sival_int = 0;
     ev.sigev_notify = SIGEV_SIGNAL;
-    ev.sigev_signo = SIGALRM;
+    ev.sigev_signo = SIGCONT/*ALRM*/;
 
     if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {
         perror("timer_create");
@@ -1469,6 +1517,7 @@
         fprintf(stderr, "Internal timer error: aborting\n");
         exit(1);
     }
+
     current_us = timeout.it_value.tv_sec * 1000000 + timeout.it_value.tv_nsec/1000;
     if (current_us && current_us <= nearest_delta_us)
         return;
@@ -1623,11 +1672,13 @@
     return err;
 }
 
+#if 0
 static void quit_timers(void)
 {
     alarm_timer->stop(alarm_timer);
     alarm_timer = NULL;
 }
+#endif
 
 /***********************************************************/
 /* host time/date access */
@@ -3409,34 +3460,6 @@
     } while ((len == -1 && errno == EINTR) || len > 0);
 }
 
-static int qemu_event_init(void)
-{
-    int err;
-    int fds[2];
-
-    err = qemu_pipe(fds);
-    if (err == -1)
-        return -errno;
-
-    err = fcntl_setfl(fds[0], O_NONBLOCK);
-    if (err < 0)
-        goto fail;
-
-    err = fcntl_setfl(fds[1], O_NONBLOCK);
-    if (err < 0)
-        goto fail;
-
-    qemu_set_fd_handler2(fds[0], NULL, qemu_event_read, NULL,
-                         (void *)(unsigned long)fds[0]);
-
-    io_thread_fd = fds[1];
-    return 0;
-
-fail:
-    close(fds[0]);
-    close(fds[1]);
-    return err;
-}
 #else
 HANDLE qemu_event_handle;
 
@@ -3444,17 +3467,6 @@
 {
 }
 
-static int qemu_event_init(void)
-{
-    qemu_event_handle = CreateEvent(NULL, FALSE, FALSE, NULL);
-    if (!qemu_event_handle) {
-        fprintf(stderr, "Failed CreateEvent: %ld\n", GetLastError());
-        return -1;
-    }
-    qemu_add_wait_object(qemu_event_handle, dummy_event_handler, NULL);
-    return 0;
-}
-
 static void qemu_event_increment(void)
 {
     if (!SetEvent(qemu_event_handle)) {
@@ -3477,7 +3489,7 @@
 #ifndef CONFIG_IOTHREAD
 static int qemu_init_main_loop(void)
 {
-    return qemu_event_init();
+  return 0;
 }
 
 void qemu_init_vcpu(void *_env)
@@ -3514,7 +3526,7 @@
     CPUState *env = cpu_single_env;
 
     if (env) {
-        cpu_exit(env);
+      cpu_exit(env);
     }
 }
 
@@ -3553,10 +3565,6 @@
 {
     int ret;
 
-    ret = qemu_event_init();
-    if (ret)
-        return ret;
-
     qemu_cond_init(&qemu_pause_cond);
     qemu_mutex_init(&qemu_fair_mutex);
     qemu_mutex_init(&qemu_global_mutex);
@@ -3568,6 +3576,7 @@
     return 0;
 }
 
+#if 0
 static void qemu_wait_io_event(CPUState *env)
 {
     while (!tcg_has_work())
@@ -3590,9 +3599,11 @@
         qemu_cond_signal(&qemu_pause_cond);
     }
 }
+#endif
 
 static int qemu_cpu_exec(CPUState *env);
 
+#if 0
 static void *kvm_cpu_thread_fn(void *arg)
 {
     CPUState *env = arg;
@@ -3612,16 +3623,18 @@
         qemu_cond_timedwait(&qemu_system_cond, &qemu_global_mutex, 100);
 
     while (1) {
-        if (cpu_can_run(env))
-            qemu_cpu_exec(env);
+        if (cpu_can_run(env)) 
+          qemu_cpu_exec(env);
         qemu_wait_io_event(env);
     }
 
     return NULL;
 }
+#endif
 
 static void tcg_cpu_exec(void);
 
+#if 0
 static void *tcg_cpu_thread_fn(void *arg)
 {
     CPUState *env = arg;
@@ -3646,6 +3659,7 @@
 
     return NULL;
 }
+#endif
 
 void qemu_cpu_kick(void *_env)
 {
@@ -3746,6 +3760,7 @@
     return 1;
 }
 
+#if 0
 static void pause_all_vcpus(void)
 {
     CPUState *penv = first_cpu;
@@ -3820,6 +3835,7 @@
     else
         tcg_init_vcpu(env);
 }
+#endif
 
 void qemu_notify_event(void)
 {
@@ -4033,32 +4049,6 @@
     return ret;
 }
 
-static void tcg_cpu_exec(void)
-{
-    int ret = 0;
-
-    if (next_cpu == NULL)
-        next_cpu = first_cpu;
-    for (; next_cpu != NULL; next_cpu = next_cpu->next_cpu) {
-        CPUState *env = cur_cpu = next_cpu;
-
-        if (timer_alarm_pending) {
-            timer_alarm_pending = 0;
-            break;
-        }
-        if (cpu_can_run(env))
-            ret = qemu_cpu_exec(env);
-        else if (env->stop)
-            break;
-
-        if (ret == EXCP_DEBUG) {
-            gdb_set_stop_cpu(env);
-            debug_requested = 1;
-            break;
-        }
-    }
-}
-
 static int cpu_has_work(CPUState *env)
 {
     if (env->stop)
@@ -4150,7 +4140,17 @@
 
 qemu_irq qemu_system_powerdown;
 
-static void main_loop(void)
+uint64_t run(uint64_t insts) {
+  qsim_icount = insts;
+
+  pthread_rwlock_rdlock(qsim_atomic_lock);
+
+  swapcontext(&main_context, &qemu_context);
+  pthread_rwlock_unlock(qsim_atomic_lock);
+  return insts - qsim_icount;
+}
+
+static void qsim_loop_main(void)
 {
     int r;
 
@@ -4159,21 +4159,22 @@
     qemu_cond_broadcast(&qemu_system_cond);
 #endif
 
-    for (;;) {
+    while (1) {
         do {
 #ifdef CONFIG_PROFILER
             int64_t ti;
 #endif
 #ifndef CONFIG_IOTHREAD
-            tcg_cpu_exec();
+            qemu_cpu_exec(first_cpu);
 #endif
 #ifdef CONFIG_PROFILER
             ti = profile_getclock();
 #endif
-            main_loop_wait(qemu_calculate_timeout());
+            //main_loop_wait(qemu_calculate_timeout());
 #ifdef CONFIG_PROFILER
             dev_time += profile_getclock() - ti;
 #endif
+
         } while (vm_can_run());
 
         if (qemu_debug_requested()) {
@@ -4846,7 +4847,78 @@
     return 0;
 }
 
-int main(int argc, char **argv, char **envp)
+void set_atomic_cb(atomic_cb_t cb) { qsim_atomic_cb = cb; }
+void set_mem_cb   (mem_cb_t    cb) { qsim_mem_cb    = cb; }
+void set_inst_cb  (inst_cb_t   cb) { qsim_inst_cb   = cb; }
+void set_int_cb   (int_cb_t    cb) { qsim_int_cb    = cb; }
+void set_magic_cb (magic_cb_t  cb) { qsim_magic_cb  = cb; }
+void set_io_cb    (io_cb_t     cb) { qsim_io_cb     = cb; }
+void set_reg_cb   (reg_cb_t    cb) { qsim_reg_cb    = cb; }
+
+int interrupt(uint8_t vec) {
+  int rvec;
+
+  pthread_mutex_lock(&qsim_irq_lock);
+  if (qsim_irq_pending == 1  && qsim_irq_vec < vec) {
+    rvec = qsim_irq_vec;
+    qsim_irq_vec = vec;
+  } else if (qsim_irq_pending == 0) {
+    rvec = -1;
+    qsim_irq_vec = vec;
+    qsim_irq_pending = 1;
+  } else {
+    rvec = vec;
+  }
+
+  // Re-notify the CPU no matter what.
+  cpu_interrupt(first_cpu, CPU_INTERRUPT_HARD);
+  qemu_notify_event();
+  pthread_mutex_unlock(&qsim_irq_lock);
+
+  // Give the caller the vector number of an interrupt that _won't_ be
+  // processed and needs to be queued if it is to be handled, or -1.
+  return rvec;
+}
+
+void qemu_init(qemu_ramdesc_t *ram, 
+               const char* ram_size,
+               int cpu_id)
+{
+    // Assemble argv based on given arguments.
+    const char *argv[] = {
+      "qemu", "-L", "qemu-0.12.3/pc-bios", "-no-hpet", 
+      "-monitor", "/dev/null", "-nographic", "-serial", "/dev/null", 
+      "-no-acpi", "-no-hpet", "-m", ram_size, NULL
+    };
+    int argc; 
+    for (argc = 0; argv[argc] != NULL; argc++);
+
+    // Set qsim-specific variables.
+    qsim_cur_cpu       = cpu_id;
+    qsim_ram           = ram;
+    qsim_qemu_is_slave = (ram != NULL);
+
+    // Set up qsim_atomic_lock
+    if (ram != NULL) qsim_atomic_lock = &qsim_ram->atomic_lock;
+
+    // Call main with newly assembled argv.
+    qsim_qemu_main(argc, argv, (const char**)environ);
+
+    // Initialize contexts.
+    getcontext(&qemu_context);
+    getcontext(&main_context);
+    
+    // Create qemu stack.
+    qemu_stack = qemu_malloc(QEMU_STACK_SIZE);
+ 
+    // Set up the qemu context.
+    qemu_context.uc_stack.ss_sp = qemu_stack;
+    qemu_context.uc_stack.ss_size = QEMU_STACK_SIZE;
+    qemu_context.uc_link = &main_context;
+    makecontext(&qemu_context, qsim_loop_main, 0);
+}
+
+int qsim_qemu_main(int argc, const char **argv, const char **envp)
 {
     const char *gdbstub_dev = NULL;
     uint32_t boot_devices_bitmap = 0;
@@ -5815,6 +5887,7 @@
     setvbuf(stdout, NULL, _IOLBF, 0);
 #endif
 
+#if 0
     if (init_timer_alarm() < 0) {
         fprintf(stderr, "could not initialize alarm timer\n");
         exit(1);
@@ -5826,6 +5899,7 @@
         icount_time_shift = 3;
         init_icount_adjust();
     }
+#endif
 
 #ifdef _WIN32
     socket_init();
@@ -5946,7 +6020,7 @@
 
 #ifndef _WIN32
     /* must be after terminal init, SDL library changes signal handlers */
-    sighandler_setup();
+    // sighandler_setup();
 #endif
 
     for (env = first_cpu; env != NULL; env = env->next_cpu) {
@@ -5986,7 +6060,7 @@
 #endif
     }
         
-
+#if 0
     switch (display_type) {
     case DT_NOGRAPHIC:
         break;
@@ -6042,6 +6116,7 @@
                 gdbstub_dev);
         exit(1);
     }
+#endif
 
     qdev_machine_creation_done();
 
@@ -6122,9 +6197,5 @@
     }
 #endif
 
-    main_loop();
-    quit_timers();
-    net_cleanup();
-
     return 0;
 }
