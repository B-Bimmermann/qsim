Qcache Todo List
----------------

- Do basic performance evaluation and testing with a null coherence protocol.
  - Doing so with no coherence protocol at all. (The interface hasn't really
    been defined)

- Write a directory class and a directory MOESI protocol.
  - Per-block locking.
  - No line can be evicted or have its state changed without locking. (Updating
    LRU information is fine)
  - Constraints:
    -Locking order: Block Locks(in directory), Set Locks in Core Order

  - Access pseudocode:
    * lock set
    * do lookup
    * hit?
      o unlock set
      o tell coherence protocol about hit
    * miss?
      o retry: select victim
      o unlock set
      o lock block and victim block in order
      o lock set
      o block in array?
        + Unlock set
        + Tell coherence protocol about hit
      o still not in array?
        + is the victim a valid block and no longer there?
          - unlock set
          - unlock block and victim block in order
          - lock set
          - goto retry
        + is the victim either unused or still there? (else)
          - evict victim and add new line to array in its place.
          - add new line to array
          - unlock set
          - tell coherence protocol about eviction
          - tell coherence protocol about miss
      o unlock victim block and block in order

  - Start with a directory MSI protocol and build from there.

- Problem: How do we decide whether to lock a line before performing a lookup?
  - cprot->hitAddr() is called while holding a lock on the address now. This
    should perhaps not always be the case. The coherence protocol should
    be able to better determine whether a lock should be acquired.
    - Add a "lock held" argument to hitAddr()?

- Our protocol still needs to be able to determine the state of the line when it
  is written, before it has consulted the other caches.
  - No we don't. It's fine. No lookup is going to see the state when it is
    STATE_X. We still have the address locks and we are thread of the cache's
    CPU.

- Start some documentation. E.g., note that private L2 cache is not shared even 
  though it shares accesses from L1i and L1d. Why? Those accesses will never be
  simultaneous in with this implementation.

- Mechanism to handle timestamp overflows.
- Mechanism to forward invalidates to instruction caches.