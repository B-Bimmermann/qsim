From 78ed77adc60f4b6d6512cdd3b685c68778143143 Mon Sep 17 00:00:00 2001
From: Pranith Kumar <bobby.prani@gmail.com>
Date: Tue, 8 Dec 2015 13:57:13 -0500
Subject: [PATCH 1/1] Qsim specific changes to the linux kernel

* Enable qsim to track process pids
* Enable qsim to track CPU boot

Signed-off-by: Pranith Kumar <bobby.prani@gmail.com>
---
 arch/arm64/include/asm/mmu_context.h |  2 +-
 arch/arm64/kernel/smp.c              |  8 ++++++--
 arch/x86/kernel/smpboot.c            | 10 ++++++++++
 kernel/sched/core.c                  | 15 +++++++++++++++
 4 files changed, 32 insertions(+), 3 deletions(-)

diff --git a/arch/arm64/include/asm/mmu_context.h b/arch/arm64/include/asm/mmu_context.h
index 8ec41e5..ac22f01 100644
--- a/arch/arm64/include/asm/mmu_context.h
+++ b/arch/arm64/include/asm/mmu_context.h
@@ -42,7 +42,7 @@ static inline void contextidr_thread_switch(struct task_struct *next)
 	"	msr	contextidr_el1, %0\n"
 	"	isb"
 	:
-	: "r" (task_pid_nr(next)));
+	: "r" (task_tgid_nr(next)));
 }
 #else
 static inline void contextidr_thread_switch(struct task_struct *next)
diff --git a/arch/arm64/kernel/smp.c b/arch/arm64/kernel/smp.c
index d3a202b..cfd98cf 100644
--- a/arch/arm64/kernel/smp.c
+++ b/arch/arm64/kernel/smp.c
@@ -76,10 +76,14 @@ enum ipi_msg_type {
  */
 static int boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
+	int ret = -EOPNOTSUPP;
 	if (cpu_ops[cpu]->cpu_boot)
-		return cpu_ops[cpu]->cpu_boot(cpu);
+		ret = cpu_ops[cpu]->cpu_boot(cpu);
 
-	return -EOPNOTSUPP;
+	if (ret != -EOPNOTSUPP)
+		asm("msr pmcr_el0, %0\n"::"r"(cpu | 0xb0070000));
+
+	return ret;
 }
 
 static DECLARE_COMPLETION(cpu_running);
diff --git a/arch/x86/kernel/smpboot.c b/arch/x86/kernel/smpboot.c
index 50e547e..11af828 100644
--- a/arch/x86/kernel/smpboot.c
+++ b/arch/x86/kernel/smpboot.c
@@ -552,11 +552,19 @@ wakeup_secondary_cpu_via_nmi(int apicid, unsigned long start_eip)
 	return (send_status | accept_status);
 }
 
+/* Use magic instruction to boot other CPUs. */
+static inline void QSIM_BOOTSTRAP(u16 cpu)
+{
+	asm volatile("mov %0, %%eax;\n cpuid;\n" :: "r"(0xb0070000 | cpu) :
+		     "%eax", "%ebx", "%edx", "%ecx");
+}
+
 static int
 wakeup_secondary_cpu_via_init(int phys_apicid, unsigned long start_eip)
 {
 	unsigned long send_status, accept_status = 0;
 	int maxlvt, num_starts, j;
+	static u16 cur_cpu = 1;
 
 	maxlvt = lapic_get_maxlvt();
 
@@ -594,6 +602,8 @@ wakeup_secondary_cpu_via_init(int phys_apicid, unsigned long start_eip)
 	pr_debug("Waiting for send to finish...\n");
 	send_status = safe_apic_wait_icr_idle();
 
+	QSIM_BOOTSTRAP(cur_cpu++);
+
 	mb();
 	atomic_set(&init_deasserted, 1);
 
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 4d870eb..f8dd7ea 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -2302,6 +2302,21 @@ context_switch(struct rq *rq, struct task_struct *prev,
 {
 	struct mm_struct *mm, *oldmm;
 
+	/* tell qsim the pid of the next task or that it is idle
+	 */
+	if (IS_ENABLED(CONFIG_X86)) {
+		if (next == rq->idle)
+			asm volatile("cpuid\n"
+				     :
+				     : "a"(0x1d1e1d1e)
+				     : "ebx", "ecx", "edx");
+		else
+			asm volatile("cpuid\n"
+				     :
+				     : "a"(0xc75c0000 | (u16)task_tgid_nr(next))
+				     : "ebx", "ecx", "edx");
+	}
+
 	prepare_task_switch(rq, prev, next);
 
 	mm = next->mm;
-- 
2.7.0

